; MONITOR 3 for the TEC-1G
; ------------------------
;  _______ ______ _____     __  _____   __  __  ____  _   _ ____
; |__   __|  ____/ ____|   /_ |/ ____| |  \/  |/ __ \| \ | |___ \
;    | |  | |__ | |   ______| | |  __  | \  / | |  | |  \| | __) |
;    | |  |  __|| |  |______| | | |_ | | |\/| | |  | | . ` ||__ <
;    | |  | |___| |____     | | |__| | | |  | | |__| | |\  |___) |
;    |_|  |______\_____|    |_|\_____| |_|  |_|\____/|_| \_|____/
;                 Coding by Brian Chiha, Oct-2023
;
; With help from Craig Hart, Mark Jelic, Ian McLean and James Elphick
;
; Constants
; ---------
; Ports
KEYB:       .equ    00H         ;Keyboard
DIGITS:     .equ    01H         ;Seven Segment Digits
SEGS:       .equ    02H         ;Seven Segment Display
SYS_INPUT:  .equ    03H         ;System Input
LCD_INST:   .equ    04H         ;LCD Instruction
LCD_DATA:   .equ    84H         ;LCD Data
LED8X8H:    .equ    05H         ;LED 8x8 Horizontal
LED8X8V:    .equ    06H         ;LED 8x8 Vertical
GLCD_INST:  .equ    07H         ;Graphics LCD Instruction
GLCD_DATA:  .equ    87H         ;Graphics LCD Data
SDIO:       .equ    0FDH        ;SD Card IO
MATRIX:     .equ    0FEH        ;QWERTY Keyboard Matrix
SYS_CTRL:   .equ    0FFH        ;System Control

; SYSCTRL  port bits
SHADOW:     .equ    01H         ;Shadow ROM
PROTECT:    .equ    02H         ;Memory Protect
EXPAND:     .equ    04H         ;Expand
CART:       .equ    10H         ;Cartridge
CAPSLOCK:   .equ    80H         ;Caps lock for Keyboard

; Monitor Control Bit
;MCB = Bits 0,1 = Data Nibbles Entered
;      Bit 2 = Address=H/Data=L mode
;      Bit 3 = LCD=H/Segment=L mode
;      Bit 4 = Disassembler View=H/Data Entry View=L mode (for segment mode only)
;      Bit 5 = Menu=L/Parameter=H Format for Menu handler (for LCD mode only)
MCB_AD_DATA .equ    04H         ;Address=H/Data=L mode
MCB_LCD_SEG .equ    08H         ;LCD=H/Segment=L mode
MCB_DIS_DE  .equ    10H         ;Disassembler View=H/Data Entry View=L mode
MCB_MEN_PAR .equ    20H         ;Menu=L/Parameter=H Format for Menu handler

; Serial Baud Delay
BAUD:       .equ    1BH         ;BAUD 4800 Delay
;BAUD:       .equ    0BH         ;BAUD 9600 Delay

; Keyboard reference
K_FN:       .equ    02H         ;Fn key on Keyboard Matrix
K_PLUS:     .equ    10H         ;+ Key
K_MINUS:    .equ    11H         ;- Key
K_GO:       .equ    12H         ;GO Key
K_ADDR:     .equ    13H         ;Address Key

; Constants
KEY_SPEED:  .equ    20H         ;Speed of auto repeat press (lower=faster)
USER_ADDR:  .equ    4000H       ;User starting address
BASE_ADDR:  .equ    0C000H      ;Start Address of monitor
LCD_ROW1:   .equ    80H         ;LCD Row 1, Column 1
LCD_ROW2:   .equ    0C0H        ;LCD Row 2, Column 1
LCD_ROW3:   .equ    94H         ;LCD Row 3, Column 1
LCD_ROW4:   .equ    0D4H        ;LCD Row 4, Column 1
MENU_PTR:   .equ    7EH         ;LCD Right Arrow

; RAM Locations
MON_RAM:    .equ    0800H       ;Monitor RAM start
STACK_SIZE: .equ    80H         ;128 Bytes
STACK_TOP:  .equ    MON_RAM+STACK_SIZE
TOP_RAM:    .equ    7FFFH       ;Highest RAM location (no expansion)

ROMSIG:     .equ    MON_RAM         ;16 byte buffer holding the ROM signature; used for cold start detection

; Monitor Configuration and display data
DISP_BUFF:  .equ    STACK_TOP       ;Display Buffer for Segments
DISP_DATA:  .equ    STACK_TOP+4     ;Display Buffer Data for Segments
CEL:        .equ    STACK_TOP+6     ;Current Editing location
MCB:        .equ    STACK_TOP+8     ;Monitor Control Byte
KEY_BUFF:   .equ    STACK_TOP+9     ;Keypress Buffer
KEY_PRESS:  .equ    STACK_TOP+10    ;Keypress Flag
KEY_AUTO:   .equ    STACK_TOP+11    ;Key Auto Increment Flag
KEY_REPEAT: .equ    STACK_TOP+12    ;Key Auto Repeat timer
KEY_BEEP:   .equ    STACK_TOP+13    ;Keypress Beep flag
KEY_SECOND: .equ    STACK_TOP+14    ;Matrix Keyboard second key Buffer
SPARE:      .equ    STACK_TOP+15    ;Spare Byte
DIS_ADDR:   .equ    STACK_TOP+16    ;Base Disassembler/Editing address
USER_INT:   .equ    STACK_TOP+18    ;User defined INT routine
USER_NMI:   .equ    STACK_TOP+20    ;User defined NMI routine
MENU_POS:   .equ    STACK_TOP+22    ;Menu listing position
MENU_SEL:   .equ    STACK_TOP+23    ;Menu pointer seletion
MENU_CNT:   .equ    STACK_TOP+24    ;Menu listing position
MENU_CFG:   .equ    STACK_TOP+25    ;Menu pointer seletion
HIGH_RAM:   .equ    STACK_TOP+27    ;High RAM address
SYS_MODE:   .equ    STACK_TOP+29    ;SYS_CTRL current monitor state
PROT_MODE:  .equ    STACK_TOP+30    ;Use Protect at GO
XPND_MODE:  .equ    STACK_TOP+31    ;Expand Mode

; Free Monitor RAM area for specific functions (08A0H).  Areas can overlap
MON_FRAM:   .equ    STACK_TOP+32    ;Free Monitor RAM Starts Here

; Parameter Base Address.  All parameters are two bytes long from this address
PARAM_DATA  .equ    MON_FRAM+32     ;Start of Parameter storage (08C0H)

; ASCII string for data entry area  ;IE "4000: 23 34 45 56 78"
DATA_BASE:  .equ    MON_FRAM        ;Base address for Data view (08A0H)
DATA_ROW:   .equ    MON_FRAM+96     ;Start of ASCII data entry string (0900H)

; Breakpoint regsiter save area.
BP_BASE_SP: .equ    MON_FRAM+2      ;Start of Register save area (08A2H)   
BP_HL:      .equ    BP_BASE_SP+2    ;HL position in BP stack
BP_REGS:    .equ    BP_BASE_SP+20   ;Top of Stack (Goes down towards MON_RAM)
BP_PC:      .equ    BP_BASE_SP+20   ;Calling Program Counter
BP_ORIG_SP: .equ    BP_BASE_SP+22   ;Original hardware stack pointer
BP_LCD:     .equ    BP_BASE_SP+24   ;LCD Screen Buffer (20x4 or 80 bytes)

; RAM for Smart Copy
COPY_START: .equ    PARAM_DATA      ;Start (08C0H)
COPY_END:   .equ    COPY_START+2    ;End
COPY_DEST:  .equ    COPY_START+4    ;Destination
COPY_PTR:   .equ    COPY_START+6    ;Pointer
COPY_EBLK:  .equ    COPY_START+8    ;End Block
COPY_CORR:  .equ    COPY_START+10   ;Correction

; RAM for To/From Addresses
DATA_FROM:  .equ    PARAM_DATA      ;From (08C0H)
DATA_TO:    .equ    DATA_FROM+2     ;To

; ----------------------------------------------------------------------------------------------------------------
; CODE start here, with code running at 0000H
; ----------------------------------------------------------------------------------------------------------------

        .org BASE_ADDR
boot:
        jp preInit

        .org BASE_ADDR+08H
rst08:  ;Key Read and Wait for key release.  (Halt simulation)
        ;Output: A = Key pressed
        jp scanKeysWait     ;Wait and Scan key routine

        .org BASE_ADDR+10H
rst10:  ;API Call Entry
        jp APICall-BASE_ADDR ;API Call routine

        .org BASE_ADDR+18H
rst18:  ;API Call 2 Entry
        jp APICall2-BASE_ADDR ;API Call 2 routine

        .org BASE_ADDR+20H
rst20:  ;Scan Segments and Keyboard.  Must be called constantly
        ;Input: DE = Pointer to LCD Segment code (Must be 6 bytes)
        ;Output: A = Key pressed if Zero flag is set
        call scanSegments   ;Multiplex the seven segments
        call scanKeys       ;Scan for key press

        .org BASE_ADDR+28H
rst28:  ;LCD Busy
        push af             ;save af
busyLoop:
        in a,(LCD_INST)     ;Read status bit on LCD
        rlca                ;put bit 7 (status) in carry
        jr c,busyLoop       ;loop if LCD is busy
        pop af              ;restore af
        ret

        .org BASE_ADDR+30H
rst30:  ;Breakpoint Entry
        ex (sp), hl         ;get return address
        ld (BP_PC),hl       ;save it
        ex (sp), hl         ;fix stack
        jp breakPoint

        .org BASE_ADDR+38H
rst38:
        push hl             ;save HL
        ld hl,(USER_INT)    ;get address at USER_INT
        ex (sp),hl          ;restore HL and put INT routine on stack
        ret

        .org BASE_ADDR+40H
;API Call Routine
; Input:   A = Function index
;          BC, DE, HL = Parameters if needed
; Corrupt: IX
APICall2:
        cp API_COUNT2/2 ;Adjust for real count
        jr c,APIGood2
        jp displayError     ;exit with Error Message
APIGood2:
        push bc             ;save BC
        push hl             ;save HL
        ld hl,APITable2  ;API Funciton Table
        add a,a             ;double it
        ld c,a              ;store index in
        ld b,0              ;bc
        add hl,bc           ;index table
        ld a,(hl)           ;store jump
        inc hl              ;address
        ld h,(hl)           ;back into
        ld l,a              ;HL
        push hl             ;IX = HL
        pop ix
        pop hl              ;restore HL
        pop bc              ;restore BC
        jp (ix)             ;Jump to API Routine

        .org BASE_ADDR+66H
NMI:
        push hl             ;save HL
        ld hl,(USER_NMI)    ;get address at USER_NMI
        ex (sp),hl          ;restore HL and put INT routine on stack
        ret

        .org BASE_ADDR+70H
;API Call Routine
; Input:   C = Function index
;          A, B, DE, HL = Parameters if needed
; Corrupt: IX
APICall:
        push af             ;save AF
        ld a,c              ;Check index is within range
        cp API_COUNT/2      ;Adjust for real count
        jr c,APIGood
        pop af              ;restore AF
        jp displayError     ;exit with Error Message
APIGood:
        push bc             ;save BC
        push hl             ;save HL
        ld hl,APITable      ;API Funciton Table
        add a,a             ;double it
        ld c,a              ;store index in
        ld b,0              ;bc
        add hl,bc           ;index table
        ld a,(hl)           ;store jump
        inc hl              ;address
        ld h,(hl)           ;back into
        ld l,a              ;HL
        push hl             ;IX = HL
        pop ix
        pop hl              ;restore HL
        pop bc              ;restore BC
        pop af              ;restore AF
        jp (ix)             ;Jump to API Routine

; Restart Handler (temp)
restartHandle:
        ret

;Interrupt Handler Stub (just return)
INTHandler:
        reti                ;Exit cleanly

;NMI Handler Stub (just return)
NMIHandler:
        retn                ;Exit cleanly


; ----------------------------------------------------------------------------------------------------------------
; CODE running in ROM proper, at C000H upwards
; ----------------------------------------------------------------------------------------------------------------

        .org BASE_ADDR+100H

preInit:
        ld sp,STACK_TOP     ;Set the Hardware Stack to top of stack in RAM
        ld hl,4000H         ;Long delay to ensure reset of latches are complete
        call timeDelay
        xor a               ;Blank the 8x8 display to prevent LED burnout
        out (LED8X8H),a        
        out (LED8X8V),a
        in a,(SYS_INPUT)    ;Check for CART presence
        ld b,a
        and CART            ;Check bit 4
        jp nz,08000H        ;Launch CARTridge code if CART present
        ld a,(XPND_MODE)    ;set Expand Mode to DIP setting
        and EXPAND          ;honor EXPAND bit (if any as Hard Reset will fix)
        ld c,SHADOW         ; activate SHADOW disable
        or c                
        out (SYS_CTRL),a
        ld (SYS_MODE),a     ;Update MONitors idea of the config
        ld a,b              ;Honor PROTECT bit
        and PROTECT
        ld (PROT_MODE),a
        ld a,(SYS_MODE)     ;Is shadow disabled ? (should be yes it is)
        and SHADOW
        jr z,hardBoot       ;if enabled, skip memcopy
        ld hl,0C000H        ;copy bottom 256 bytes of ROM to RAM at 0000
        ld de,0000H         ;so RST vectors etc. are in RAM now
        ld bc,0100H
        ldir

;Place initialisation routines here.  MemCheck, RAM defaults
hardBoot:
        ld hl,USER_ADDR     ;fixup edit location for startup
        ld (CEL),hl
        ld (DATA_BASE),hl   ;update base address
        in a,(SYS_INPUT)    ;read simp buffer for keyboard input type
        rrca                ;check bit 0
        jr c,checkMatrix    ;if set, matrix keyboard in use
        in a,(KEYB)         ;Check for Fn key press when RESET key is released
        and 20H             ;Check bit 5
        jr $+10             ;skip to jr z,hardInit
checkMatrix:
        call matrixScan
        jr nz,$+7           ;no key pressed, skip hard init       
        ld a,e              ;grab first key pressed
        cp K_FN             ;is it the FN key?
        jr z,hardInit       ;Fn Key pressed, do a hard initialise
        ;Look for hard reset flag
        ld hl,SOFTWARE
        ld de,ROMSIG
        ld b,10h
        call stringCompare
        jr z,softBoot       ;Yes, just softboot
hardInit:
        ;Honour Expand
        in a,(SYS_INPUT)    ;read simp buffer for real expand bit
        and EXPAND          ;honor EXPAND bit
        ld (XPND_MODE),a    ;set Expand Mode to DIP setting
        ld b,a              ;save expand status
        ld a,(SYS_MODE)     ;get system mode
        and -EXPAND-1       ;clear bit
        or b                ;add it back if set
        out (SYS_CTRL),a    ; update latch
        ld (SYS_MODE),a     ; save state
        ;Copy ROMSTR into RAM - warm boot flag
        ld hl,SOFTWARE
        ld de,ROMSIG
        ld bc,10h
        ldir
        ;Default monitor RAM variables
        ld hl,defaults      ;Start from MCB
        ld de,CEL           ;Set to CEL and onwards in RAM
        ld bc,defaultsSize  ;Load defaultsSize bytes
        ldir
        ;LCD initialise
        ld bc,400H+LCD_INST ;4 instructions, LCD Instruction port
        ld hl,LCDInitTable  ;LCD instructions table
        ld de,1000H
        dec de
        ld a,e
        or d
        jr nz,$-3
        outi                ;send it to LCD
        jr nz,$-10          ;loop again
        ;Display Welcome Message
        ld hl,hardResetMessage
        call stringToLCD    ;print line to LCD
        ;play a tone...
        ld de,hardResetTune ;Set DE to tune data
        call playTune
        ;wait a bit
        ld hl,0FEEEH        ;delay
        call timeDelay

        ;TODO add more here...

;Soft Reset call and fallthrough for Hard Reset and GO return address
softBoot:
        ld sp,STACK_TOP     ;Set the Hardware Stack to top of stack in RAM
        ld a,(SYS_MODE)     ;reset hardware to MONitor mode
        out (SYS_CTRL),a
        ld hl,mainMenuCFG   ;set up 1G Menu
        call menuInit
        ;reset MCB
        ld a,(MCB)          ;Get MCB
resetMCB:
        and 0D8H            ;Mask out params, nibble and mode bits
updateMCB:
        ld (MCB),a          ;Save MCB back

        ;fill display buffer with current editing location
setDispBuffer:
        call beep           ;beep the speaker bit
        ld de,(CEL)         ;load DE with current editing location
        call CELToSeg       ;convert CEL and its value to display buffer
        call setDots        ;set decimal point on segments
        ;update LCD screen
setLCD:
        call updateLCD      ;Update LCD screen (and also DISP_BUFF if LCD)

        ;main system loop
mainLoop:
        call scanDisplayBuff ;Multiplex the seven segments
        call scanKeys       ;Scan for key press
        ld hl,KEY_REPEAT    ;get the key repeat timer
        jr z,keyDelay       ;key has been pressed
        ld (hl),00H         ;reset delay counter
        jr mainLoop         ;loop back to the main loop
keyDelay:
        jr c,keyFirst       ;new key press first detection
        dec (hl)            ;key held, decrease timer
        jr nz,mainLoop      ;loop back to the main loop if timer is not zero
        ld (hl),KEY_SPEED   ;short timer set for subsequent presses
keyFirst:
        dec (hl)            ;set timer off
        ;key has been detected handle it
        ld hl,MCB           ;get the MCB
        bit 3,(hl)          ;is bit 3 set? LCD/Segment
        jp nz,keyProcessLCD ;yes, process key for LCD

        ;process key press for segment data entry (A = key, HL = MCB)
        ;set C=key pressed, B=MCB, HL=CEL
keyProcessSegs:
        ld c,a              ;store key pressed
        ld a,(HL)           ;get MCB
        ld b,a              ;save in B
        ld a,c              ;restore key pressed
        ld hl,(CEL)         ;load Current Editing location in HL
keyPlus:
        cp K_PLUS           ;Plus key press
        jr nz,keyMinus      ;no, Check Minus key
        call checkFnKey     ;check for Function key
        jp z,fnPlus         ;handle Fn+Plus key
        inc hl              ;move to next CEL
updateCEL:
        ld (CEL),hl         ;save CEL
        ld a,b              ;get MCB
        jr resetMCB         ;reset MCB and jump to Main loop
keyMinus:
        cp K_MINUS          ;Minus key press
        jr nz,keyAddress    ;no, Check Address key
        call checkFnKey     ;check for Function key
        jp z,fnMinus        ;handle Fn+Minus key
        dec hl              ;move to previous address
        jr updateCEL        ;update CEL and return
keyAddress:
        cp K_ADDR           ;Address key press
        jr nz,keyGo         ;no, Check Go key
        ld a,b              ;get MCB
        xor MCB_AD_DATA     ;flip Address/Data bit
        and 0FCH            ;clear nibble counter
        jr updateMCB        ;update MCB and jump to Main loop
keyGo:
        cp K_GO             ;Go key press
        jr nz,keyHex        ;no, Must be Hex key
runRoutine:
        call beep           ;indicate key press
        ld a,(SYS_MODE)     ;reset hardware to MONitor mode
        ld b,a
        ld a,(PROT_MODE)    ;enable PROTECT if configured
        or b
        out (SYS_CTRL),a
        ld de,softBoot      ;get return address
        push de             ;put return address on stack
        jp (hl)             ;jump to CEL and execute it
keyHex:
        ld a,b              ;get MCB
        bit 2,a             ;check mode Address or Data
        jr nz,updateAddress ;update address
        call checkFnKey     ;check for Function key
        jr z,keyFn          ;jump to Function key routine
        ;update data and set nibble decimal point and auto address increment
        ld a,b              ;get MCB
        and 03H             ;mask out to nibble counter
        cp 02H              ;is this the second nibble?
        ld a,b              ;get orginal MCB
        jr nz,enterNibble   ;no, just enter the nibble into (CEL)
        push af             ;save MCB
        ld a,(KEY_AUTO)     ;check for auto address increment flag
        or a                ;is it zero?
        jr nz,skipAutoInc   ;no, don't update CEL
        inc hl              ;move to next CEL to enter nibble
        ld (CEL),hl         ;store it
skipAutoInc:
        pop af              ;restore MCB
        and 0FCH            ;clear nibble counter
enterNibble:
        inc a               ;add one to nibble conter
        ld (MCB),a          ;store it
        ld a,c              ;get key
        rld                 ;shift key into CEL
        jp setDispBuffer    ;jump back to main loop
        ;update address
updateAddress:
        ld hl,CEL           ;set hl to address of CEL
        ld a,c              ;load a with hex key pressed
        rld                 ;shift key into lower byte of CEL
        inc hl              ;move to upper byte
        rld                 ;shift carry nibble into upper byte
        ld hl,(CEL)
        ld (DATA_BASE),hl
        jp setDispBuffer    ;jump back to main loop
        ;function key handler
keyFn:
        ld de,functionJumpTable ;reference jump table
        ld a,c              ;load a with hex key pressed
        add a,a             ;double it
        ld l,a              ;store index in
        ld h,0              ;hl
        add hl,de           ;index DE with HL
        ld a,(hl)           ;store jump
        inc hl              ;address
        ld h,(hl)           ;back into
        ld l,a              ;HL
        ld de,softBoot      ;get return address
        push de             ;put return address on stack
        jp (hl)             ;jump to HL and execute it
        ;function + Plus handler
fnPlus:
        ;shift from CEL to High RAM 1 byte up, make CEL=0
        ld de,(CEL)         ;get current CEL
        ld hl,(HIGH_RAM)    ;get high ram
        or a                ;clear carry
        sbc hl,de           ;get difference
        jp m,setDispBuffer  ;high ram < cel, exit
        ex de,hl            ;set hl to CEL
        ld (COPY_START),hl  ;move from CEL
        inc hl
        ld (COPY_DEST),hl   ;save from CEL+1
        ld hl,(HIGH_RAM)    ;HL = 7FFEH
        dec hl
        ld (COPY_END),hl    ;save from HIGH_RAM-1
        call smartCopyDirect ;do the smart update
        ld hl,(CEL)         ;get CEL
        ld (hl),00H         ;put zero in CEL
        jp setDispBuffer    ;jump back to main loop
fnMinus:
        ;shift from CEL to High RAM 1 byte down, make High RAM=0
        ld de,(CEL)         ;get current CEL
        ld hl,(HIGH_RAM)    ;get high ram
        or a                ;clear carry
        sbc hl,de           ;get difference
        jp m,setDispBuffer  ;high ram < cel, exit
        ex de,hl            ;set hl to CEL
        ld (COPY_DEST),hl   ;move to CEL
        inc hl
        ld (COPY_START),hl  ;save from CEL+1
        ld hl,(HIGH_RAM)    ;HL = 7FFFH
        ld (COPY_END),hl    ;save from HIGH_RAM
        call smartCopyDirect ;do the smart update
        ld hl,(HIGH_RAM)    ;get High RAM
        ld (hl),00H         ;put zero in High RAM
        jp setDispBuffer    ;jump back to main loop

        ;process key press for segment data entry (A = key, HL = MCB)
keyProcessLCD:
        cp K_PLUS           ;is it the plus key
        jr nz,keyMinusLCD   ;no, try -
keyPlusLCD:
        ld a,(MENU_CNT)     ;get menu count
        dec a               ;adjust for 0
        ld b,a              ;save it in B
        ld a,(MENU_SEL)     ;get current menu selection
        cp b                ;is count = selection?
        jp z,mainLoop       ;yes, ignore and return to menu
        inc a               ;move to next item
        ld (MENU_SEL),a     ;save it
        ld c,a              ;save for later
        ld a,(MENU_POS)     ;get menu display position
        add a,3             ;add 3
        ld b,a              ;B = menu pos
        ld a,c              ;A = menu sel
        cp b                ;if b+3>a then no change
        jp c,setDispBuffer  ;yes return to menu
        ld a,(MENU_POS)     ;get menu display position
        inc a               ;update it
        ld (MENU_POS),a     ;save it
        jp setDispBuffer    ;exit and update LCD
keyMinusLCD: 
        cp K_MINUS          ;is it the minus key
        jr nz,keyGoLCD      ;no, try GO
        ld a,(MENU_SEL)     ;get current menu selection
        dec a               ;decrease it by 1
        jp m,mainLoop       ;if negative exit
        ld (MENU_SEL),a     ;save it
        ld c,a              ;save for later
        ld a,(MENU_POS)     ;get menu display position
        ld b,a              ;B = menu pos
        ld a,c              ;A = menu sel
        cp b                ;if b<a then no change
        jp nc,setDispBuffer ;return
        ld (MENU_POS),a     ;save it
        jp setDispBuffer    ;exit
keyGoLCD:
        cp K_GO             ;is it the GO key
        jr nz,keyAddressLCD ;no, try AD
        bit 5,(hl)          ;check MCB
        jp nz,switchMode    ;in Parameter mode, switch out and exit back to calling routine
        ld a,(MENU_SEL)     ;get current menu selection
        call menuIndex      ;set HL to menu config at index A
        ld a,(hl)           ;skip menu label
        inc hl          
        or a                ;is it zero
        jr nz,$-3           ;repeat until zero found
        ld a,(hl)           ;fix HL
        inc hl              ;for executing
        ld h,(hl)
        ld l,a
        jp runRoutine       ;execute it safely
keyAddressLCD:
        cp K_ADDR           ;is key AD?
        jp nz, keyHexLCD    ;no, try Hex key
        call switchMode     ;exit out of LCD mode
        jp softBoot         ;and return
keyHexLCD:
        ;only applicable in Parameter mode
        bit 5,(hl)          ;check MCB
        jp z, mainLoop      ;in Menu Mode, ignore key
        ld c,a              ;save key press
        ld a,(MENU_SEL)     ;get current menu selection
        call menuIndex      ;set HL to menu config at index A
        ld a,(hl)           ;skip menu label
        inc hl          
        or a                ;is it zero
        jr nz,$-3           ;repeat until zero found
        ld a,(hl)           ;fix HL
        inc hl              ;for updating
        ld h,(hl)
        ld l,a
        ld a,c              ;restore key pressed
        rld                 ;shift key into lower byte of CEL
        inc hl              ;move to upper byte
        rld                 ;shift carry nibble into upper byte
        jp setDispBuffer    ;exit

; Check for Fn key pressed.
; Output: Zero is set if Fn key is pressed
checkFnKey:
        in a,(SYS_INPUT)    ;read simp buffer
        rrca                ;check bit 0
        jr c,checkSecond    ;if set, matrix keyboard in use
        in a,(KEYB)         ;check keyboard latch
        and 20H             ;is bit 5 set
        ret
checkSecond:
        ld a,(KEY_SECOND)   ;get second key if any
        cp K_FN             ;is it the FN key?
        ret

; Update LCD screen.  Either show a menu if LCD mode or byte information if
; segment mode
updateLCD:
        ld b,01H            ;clear LCD instruction
        call commandToLCD   ;update LCD
        ld hl,MCB           ;get the MCB
        bit 3,(hl)          ;is bit 3 set? LCD/Segment
        jp nz,LCDMenu       ;LCD menu mode is set
        bit 4,(hl)          ;is bit 4 set? Disassembly / Data view
        jp nz,LCDDisView    ;display Disassembly View
LCDDataView:
        ;get difference between CEL and DATA_BASE
        ;if > 4 then move DATA_BASE = CEL
        ;if < 0 then move DATA_BASE = CEL-4
        ld de,(CEL)         ;set HL to CEL
        ld hl,(DATA_BASE)   ;set DE to DATA_BASE
        ex de,hl            ;swap them
        or a                ;clear carry
        sbc hl,de           ;get the difference
        ex de,hl            ;swap them so HL=DATA_BASE
        ld bc,0FFFCH        ;set BC to -4
        jr c,adjBase        ;its negative
        ld a,e              ;check out difference
        cp 5                ;is it 5 or more?
        jr c,skipAdjBase    ;no, skip adjust base
        ld bc,0000H         ;set BC to 5
adjBase:
        ld hl,(CEL)         ;load HL with CEL
        add hl,bc           ;modify HL with offset
        ld (DATA_BASE),hl   ;update base address
skipAdjBase:
        ;adjust base
        ld bc,0005          ;set BC = 5 five byte to display
        or a                ;clear carry
        sbc hl,bc           ;set HL = HL - 5 move 5 back
        ld b,3              ;three lines
        ld de,LCDBaseRows   ;set de to first row
LCDDataRow:
        push bc             ;save BC
        ld a,(de)           ;get row value
        inc de              ;move to next row
        ld b,a              ;set B as LCD row
        call commandToLCD   ;update LCD
        ld b,c              ;load byte count in B
        push de             ;save row table
        ld de,DATA_ROW      ;point to Data Entry RAM
        call genDataDump    ;fill DE with data dump line
        push hl             ;save HL
        ld hl,DATA_ROW      ;point to Data Entry RAM start
        call stringToLCD    ;print line to LCD
        pop hl              ;get current address
        pop de              ;restore row table
        pop bc              ;restore BC
        djnz LCDDataRow     ;do for all four rows

        ;draw disassembly line
        ld a,(de)           ;get row value
        ld b,a              ;set B as LCD row
        call commandToLCD   ;update LCD
        call calcDisAddress ;get actual dis address from CEL
        ld hl,(DIS_ADDR)    ;set DE to DIS_ADDR
        ld (DISFROM),hl     ;user DIS_ADDR as start address for disassembler
        call drawDisRow     ;Draw the Disassembly line

        ;set cursor
        ld hl,(CEL)         ;load HL with CEL
        ld bc,(DATA_BASE)   ;load BC with DATA_BASE
        or a                ;reset carry
        sbc hl,bc           ;get difference between HL and BC
        ld a,l              ;load difference in a
        ld c,a              ;save to C
        add a,a             ;double A
        add a,c             ;add C
        add a,LCD_ROW2+5    ;add 5 to set row 1, col 5
        ld b,a              ;set LCD command
        call commandToLCD   ;move cursor to correct position
        ld a,MENU_PTR       ;display ->
        jp charToLCD        ;update LCD

; Work out valid Disassembly start based on where CEL is.
LCDDisView:
        call calcDisAddress ;work out Actual disassembly address from CEL
        ;Display disassembly in 4 rows
        ld (DISFROM),hl     ;Store it in the disassembler start address
        ld b,4              ;four lines
        ld de,LCDBaseRows   ;set DE to second row
LCDDisRow:
        push bc             ;save BC
        ld a,(de)           ;get row value
        inc de              ;move to next row
        ld b,a              ;set B as LCD row
        call commandToLCD   ;update LCD
        call drawDisRow     ;Draw the Disassembly line
        pop bc              ;restore BC
        djnz LCDDisRow      ;do for all four rows
        ret
LCDMenu:
        ;Draw the menu
        call menuDraw       ;display menu items
        ;set segment text
        ld hl,menuSegmentData
        ld de,DISP_BUFF
        ld b,6
LCDSegLoop:
        ld a,(hl)
        call ASCIItoSegment ;convert A to segment code
        ld (de),a
        inc hl
        inc de
        djnz LCDSegLoop
        ret

; Update LCD with Disassembly Line: 
; Input: DISFROM is to be be set, IE , ld (DISFROM),hl
; Output: On LCD as current cursor: IE: "4000: LD A,34"
; Destroy: HL,A
drawDisRow:
        push de             ;save row table
        call disStart       ;Generate disassembly from command after CEL
        ld hl,DISLINE1      ;Point to first line
        ld a,":"            ;load A with colon
        ld (DISLINE1+4),a   ;place colon after address
        ld a," "            ;load A with space
        ld (DISLINE1+5),a   ;just display address
        xor a               ;zero A
        ld (DISLINE1+6),a   ;just display address
        call stringToLCD    ;update LCD
        ld hl,DISLINE2      ;Point to second line
        call stringZeroSpace ;Place 0 at actual end of stirng
        call stringToLCD    ;update LCD
        pop de              ;restore row table
        ret

; Monitor routines
; ----------------

; Product a short Beep from the speaker
; Input: N/A
; Destroys: A
beep:
        ld a,(KEY_BEEP)     ;check sound flag
        or a                ;is it zero?
        ret nz              ;exit if not zero
        push bc             ;save BC
        ld c,40H            ;Tone count
        xor a               ;clear A
beepLoop:
        out (DIGITS),a      ;output to segment latch
        ld b,40H            ;set delay
        djnz $              ;delay
        xor 80H             ;toggle speaker bit
        dec c               ;decrease count
        jr nz,beepLoop      ;repeat until c is zero
        pop bc              ;restore BC
        xor a               ;clear A
        out (DIGITS),a      ;output to segment latch
        ret

; Move Current Editing Location in Display Buffer
; Input: DE = current editing location
; Destroys: HL, DE, BC
CELToSeg:
        ex de,hl            ;swap DE with HL
        ld de,DISP_BUFF     ;point DE to display buffer
        ld a,h              ;get high byte
        call convAToSeg     ;convert A to segment
        ld a,l              ;get low byte
        call convAToSeg     ;convert A to segment
        ld a,(hl)           ;get data value to convert

; Convert register A to Seven Segment
; Inputs: A = byte to convert, DE = address to store segment values (2 bytes)
; Destroys: BC
convAToSeg:
        push af             ;save AF
        rlca                ;move upper nibble to lower
        rlca
        rlca
        rlca
        call convNibToSeg   ;convert lower nibble to segment
        pop af              ;restore AF
convNibToSeg:
        and 0FH             ;mask out upper nibble
        ld bc,hexToSegmentTable ;point BC to segment table
        add a,c             ;index table with A
        ld c,a
        ld a,(bc)           ;get segment data
        ld (de),a           ;store segment data in DE
        inc de              ;move to next DE address
        ret

; Sets the Segement decimal point depending on what mode the TEC is in.
; Either Address edit or Data edit.  And nibble data entry
; Destroys: A, B, HL
setDots:
        ld hl,DISP_BUFF     ;point HL to address location in display buffer
        ld b,04H            ;four dots for address
        ld a,(MCB)          ;get monitor control byte
        bit 2,a             ;check address/data bit status
        jr nz,setDot        ;Address mode, set 4 dots
        ld b,02H            ;two dots for data
        ld hl,DISP_DATA     ;point HL to data location in display buffer
        and 03H             ;mask out nibble bits
        or a                ;is it zero?
        jr z,setDot         ;yes, display two dots
        dec a               ;subract 1
        or a                ;is it zero
        jr nz,$+3           ;no, skip buffer move
        inc hl              ;move to lower nibble of display
        dec b               ;set only one dot
setDot:
        set 4,(hl)          ;set segment decimal place dot ON
        inc hl              ;move to next segment
        djnz setDot         ;repeat if necessary
        ret

; Entry to multiplex the monitor display buffer
scanDisplayBuff:
        ld de,DISP_BUFF     ;point DE to display buffer location

; Multiplex the Seven Segment displays with the contents of DE
; Inputs: DE = 6 byte location of segment data
; Destorys: A, B
scanSegments:
        ld b,00100000B      ;left most digit port address
scanLoop:
        ld a,(de)           ;load A with Segment data
        out (SEGS),a        ;send it to LED Segment
        ld a,b              ;get digit port address
        out (DIGITS),a      ;light up digit
        ld b,40H            ;set on delay
        djnz $              ;delay
        inc de              ;move to next buffer location
        ld b,a              ;save current digit reference
        xor a               ;zero A
        out (DIGITS),a      ;blank digits
        rrc b               ;rotate digit port bit to the right
        jr nc,scanLoop      ;if not on last digit repeat
        out (SEGS),a        ;clear LED Segment
        ret

; ASCII string to LCD.  Writes a string to the current cursor location on the LCD
; Inputs: HL = ASCII string terminated with zero byte
; Destroys: A, HL (moves to end of list)
stringToLCD:
        ld a,(hl)           ;get ASCII character
        inc hl              ;move to next ASCII character
        or a                ;is it zero?
        ret z               ;yes, exit
        rst 28H             ;wait until LCD is not busy
        out (LCD_DATA),a    ;send ASCII to LCD Data port
        jr stringToLCD      ;repeat

; ASCII character to LCD.  Writes one character to the LCD as the current curso locaiton
; Inputs: A = ASCII character
; Destroys: none
charToLCD:
        rst 28H             ;wait until LCD is not busy
        out (LCD_DATA),a    ;send ASCII to LCD Data port
        ret

; Command to LCD.  Sends an LCD instruction to the LCD
; Inputs: B = Instruction byte
; Destroys: none
commandToLCD:
        push af             ;save AF
        rst 28H             ;wait until LCD is not busy
        ld a,b              ;move instruction into A
        out (LCD_INST),a    ;send byte to instruction port
        pop af              ;restore AF
        ret

; LCD busy check.  Checks the LCD busy flag and loops until LCD isn't busy
; Inputs: nothing
; Destorys: none
LCDBusy:
        push af             ;save af
        in a,(LCD_INST)     ;Read status bit on LCD
        rlca                ;put bit 7 (status) in carry
        jr c,$-3            ;loop if LCD is busy
        pop af              ;restore af
        ret

; Universal Key input detection routine.  Responds to Hex keypad or Matrix Keyboard
; Return: A = key value
;         zero flag set if a key is pressed
;         carry flag set if press detected of a new key
;         carry flag not set for key pressed and held
; Destroys: DE if using Matrix Keyboard
scanKeys:
        ;Detect keyboard input method
        in a,(SYS_INPUT)    ;read simp buffer
        rrca                ;check bit 0
        jr c,keyboardScan   ;if set, matrix keyboard in use
        ;Check keypad for press via keyboard decoder
        and 20H             ;check bit 6 (now 5) for keypress on keypad
        jr z,keyPress       ;bit is low, a key is pressed
        ld (KEY_PRESS),a    ;set key press to non zero
        ret                 ;return non zero for no key press
keyPress:
        ld a,(KEY_PRESS)    ;get key press flag
        or a                ;has it been already pressed (held down)?
        ld a,(KEY_BUFF)     ;set a to current key pressed if returning
        ret z               ;key pressed and held, return zero and carry not set
        xor a               ;clear a
        ld (KEY_PRESS),a    ;set key press flag to zero
        ;Universal key reader
        in a,(KEYB)         ;read key pressed
        and 1FH             ;mask out high bits
keyExit:
        cp a                ;set zero flag
        scf                 ;set carry flag
        ld (KEY_BUFF),a     ;save key pressed into key buffer
        ret

; Matrix Keyboard handler.  If no key or invalid key press
keyboardScan:
        call matrixScan     ;detect if key has been pressed
        jr z,keyboardFetch  ;yes, continue with a key press flow
        ld (KEY_PRESS),a    ;set key press to non zero
        ret                 ;return non zero for no key press
keyboardFetch:
        ;E = key, D = second key
        ld a,d              ;get seocnd key press if any
        ld (KEY_SECOND),a   ;store second key press
        ld a,e              ;get first key press
        ;Need to check if key is 0-F, +, -, GO or AD
        ;0-9 = 13H-1CH, A-F = 24H-29H
        ;AD = 3 or C, GO = 4 or A, - = 5, + = 6
        cp 2AH              ;is it greater than 29H?
        jr nc,keyBad        ;yes, return with non zero
        cp 24H              ;is it greater than 24H? (in range)
        jr c,keyNumber      ;no, could be a number
        sub 1AH             ;adjust alpha to be A-F
        jr keyGood          ;clean exit
keyNumber:
        cp 1DH              ;is it greater than 1CH?
        jr nc,keyBad        ;yes, return with non zero
        cp 13H              ;is it greater than 13H? (in range)
        jr c,keySpecial     ;no, could be special key
        sub 13H             ;adjust for number 0-9
        jr keyGood          ;clean exit
keySpecial:
        cp 0CH              ;is it ESC?
        jr nz,$+6           ;no, keep checking
        ld a,K_ADDR         ;set key to AD
        jr keyGood          ;clean exit
        cp 0AH              ;is it Enter?
        jr nz,$+6           ;no, keep checking
        ld a,K_GO           ;set key to GO
        jr keyGood          ;clean exit
        cp 07H              ;is it greater than 06H?
        jr nc,keyBad        ;yes, return with non zero
        cp 03H              ;is it less than 3?
        jr c,keyBad         ;yes, return with non zero
        sub 3               ;subtract 3
        xor 03H             ;flip bits
        add a,10H           ;adjust special to be 10H-13H
keyGood:
        ld e,a              ;store key
        ld a,(KEY_PRESS)    ;get key press flag
        or a                ;has it been already pressed (held down)?
        ld a,(KEY_BUFF)     ;set a to current key pressed if returning
        ret z               ;key pressed and held, return zero and carry not set
        xor a               ;clear a
        ld (KEY_PRESS),a    ;set key press flag to zero
        ld a,e              ;restore key
        jr keyExit          ;clean exit
keyBad:
        or 1                ;reset zero flag
        ret                 ;return non zero for invalid key press

; Scan keys and wait until key released to get next key
; Input: none
; Return: A = key pressed
;         Zero flag is set
; Destroys: DE if using Matrix Keyboard
scanKeysWait:
        call scanKeys       ;check for key pressed
        ld a,(KEY_PRESS)    ;is a key currently pressed?
        or a                ;is it zero (pressed)
        jr z,scanKeysWait   ;repeat until key is released
        call scanKeys       ;check for key pressed
        jr nz,$-3           ;repeat scanKeys until a key is pressed
        ret

; Toggles LCD Menu or Segment Data entry mode
switchMode:
        ld a,(MCB)          ;get MCB
        xor MCB_LCD_SEG     ;toggle Bit 3
        res 5,a             ;reset Parameter bit
        ld (MCB),a          ;save it back
        ret

; Toggles Data Entry View or Disassembler View
switchView:
        ld a,(MCB)          ;get MCB
        xor MCB_DIS_DE      ;toggle Bit 4
        ld (MCB),a          ;save it back
        ret

; ASCII to Segment.  Converts an ASCII character to Seven Segment character
; Input: A = ASCII character
; Return: A = Segment character or 0 if out of range
; Destroys: none
ASCIItoSegment:
        sub 20H             ;adjust for table lookup
        jr c,a2sExit        ;out of range
        cp 60H              ;check upper range
        jr c,a2sLookup      ;okay
a2sExit:
        xor a               ;set return value to zero
        ret
a2sLookup:
        push hl             ;save HL
        ld hl,ASCIISegTable ;point hl to ASCII segment table
        add a,l             ;index l
        ld l,a              ;save l
        ld a,(hl)           ;get value in table
        pop hl              ;restore HL
        ret                 ;exit

; Software ID.  Get Software ID String
; Input: nothing
; Return: HL = Pointer to SOFTWARE ASCIIZ String
; Destroys: none
softwareID:
        ld hl,SOFTWARE      ;return the ID string pointer
        ret

; Version ID.  Get Version Number and Version String
; Input: nothing
; Return: HL = Pointer to Release ASCIIZ String
;         BC = Release major version number
;         DE = Release minor version number
; Destroys: none
versionID:
        ld hl,RELEASE      ;return the ID string pointerB
        ld bc,(RELMAJOR)   ;return major version as a number
        ld de,(RELMINOR)   ;return minor version as a number
        ret

; Set serial for Ready To Transmit.  Must be called prior to any TEC to Serial
; routine
; Input: none
; Destroy: A
readyToTransmit:
        call serialEnable   ;enable serial
        push hl             ;save hl
        ld hl,2000H         ;small
        call timeDelay      ;delay
        pop hl              ;restore HL
        ret

; Bit Bang FTDI USB tranmit routine.  Transmit one byte via the FTDI USB serial
; connection.  It assumes a uart connection of 4800-8-N-2
; Input: A = byte to transmit
; Output: nothing
; Destroy: none
txByte:
        push af             ;save AF
        push bc             ;save BC
        push hl             ;save HL
        ld hl,BAUD          ;set HL to Baud delay
        ld c,a              ;save transmit byte in C
        ;transmit the start bit
        xor a               ;clear A
        out (DIGITS),a      ;pull D6 low
        call timeDelay      ;do a baud delay
        ;transmit the byte
        ld b,8              ;eight bits to send
        rrc c               ;move fist bit into carry flag
sendBit:
        rrc c               ;shift to bit 6
        ld a,c              ;load byte in A
        and 40H             ;mask out all bits except 6
        out (DIGITS),a      ;output the bit
        call timeDelay      ;do a baud delay
        djnz sendBit        ;send next bit
        ;transmit stop bits
        ld a,40H            ;set bit
        out (DIGITS),a      ;output the bit
        call timeDelay      ;do a baud delay
        call timeDelay      ;do a baud delay x2 (two stop bits)
        pop hl              ;restore HL
        pop bc              ;restore BC
        pop af              ;restore AF
        ret

; Bit Bang FTDI USB receive routine.  Receive one byte via the FTDI USB serial
; connection.  It assumes a uart connection of 4800-8-N-2
; Input: nothing
; Return: A = byte received
; Destroy: none
rxByte:
        push bc             ;save BC
        push hl             ;save HL
startBit:
        in a,(SYS_INPUT)    ;read system input for High to Low on Bit 7
        rlca                ;put bit 7 (TX line) in carry
        jr c,startBit       ;loop if TX line is high
        ;start bit detected
        ld hl,BAUD          ;set HL to Baud delay
        srl h               ;half the delay
        rr l
        call timeDelay      ;do a baud delay
        in a,(SYS_INPUT)    ;get start bit
        rlca                ;move bit 7 into carry
        jr c,startBit       ;start bit too short, try again
        ;valid start bit detected
        ld b,8              ;eight bits to receive
getBit:
        ld hl,BAUD          ;set HL to Baud delay
        call timeDelay      ;do a baud delay
        in a,(SYS_INPUT)    ;get data bit
        rlca                ;move bit 7 into carry
        rr c                ;rotate register C and put carry in bit 7
        djnz getBit         ;get next bit
        ld a,c              ;load byte C to A
        or a                ;clear carry flag
        pop hl              ;restore HL
        pop bc              ;restore BC
        ret

; Time delay.  16-bit Delay routine
; Input: HL = delay amount
; Destroy: none
timeDelay:
        push hl             ;save HL
        push de             ;save DE
        ld de,1             ;load DE with 1
        sbc hl,de           ;subtract 1 from HL
        jp nc,$-2           ;repeat subtraction until HL=0
        pop de              ;restore DE
        pop hl              ;restore HL
        ret

; INTEL Hex Load Routine.
; Intel Hex file format is a string of ASCII with the following parts:
; MARK | LENGTH | ADDRESS | RECORD TYPE | DATA | CHECKSUM
; :10200000210621CD7D20CD98203A00213C320021AF <- EXAMPLE LINE
; MARK is a colon character, LENGTH is the number of bytes per line, ADDRESS  is
; the 2 byte address of where the data is to be stored.  RECORD TYPE is 00 for
; Data and 01 for EOF.  DATA is the bytes to be stored.  CHECKSUM is the addition of
; all bytes in the one line.
; Input: nothing
; Output: nothing
; Destroy: HL,DE,BC,A
intelHexLoad:
        ld a,(SYS_MODE)     ;reset hardware to MONitor mode
        ld b,a
        ld a,PROTECT        ;Disable PROTECT during load
        cpl
        and b
        out (SYS_CTRL),a
        call intelLoader    ;call the load routine, set zero if passed
        ld a,(SYS_MODE)     ;reset hardware to MONitor mode
        out (SYS_CTRL),a
        jp z,displayPass    ;if checksum good then display pass
        jp displayError     ;else display error

; Intel Hex Load Routine.
; Returns: Zero Flag set = Pass, Zero Flag not set = Fail
intelLoader:
        xor a               ;zero A
        ld c,a              ;clear checksum
        ;Get header information
intelMark:
        call rxByte         ;Get Byte from FTDI USB driver
        cp ':'              ;Is byte received a colon?
        jr nz,intelMark     ;No, loop until a colon is found
        call getHexByte     ;Convert ASCII to Byte (Length)
        ld b,a              ;Store Record Length in B
        call getHexByte     ;Convert ASCII to Byte (Destination address)
        ld h,a              ;Store High Address byte in H
        call getHexByte     ;Convert ASCII to Byte (Destination address)
        ld l,a              ;Store Low Address byte in L

        ;Display indication that file is loading
        out (SEGS),a        ;load low address byte to segments
        ld a,1              ;set first segment
        out (DIGITS),a      ;light up first segment

        call getHexByte     ;Convert ASCII to Byte (Record Type)
        jr nz,intelCheckSum ;Anything non zero treat as EOF

        ;C=checksum, B=number of bytes, HL=destination address
        ;Load bytes to (HL), B times
intelLoad:
        call getHexByte     ;Convert ASCII to Byte (Data)
        ld (hl),a           ;store data in RAM
        ld d,a              ;copy A to D for later checking
        ld a,(hl)           ;read back value stored
        cp d                ;check if we stored the value successfully
        ret nz              ;exit with ZF not set if the store value check failed
        inc hl              ;move to next RAM location
        djnz intelLoad      ;repeat until B=0
        call intelCheckSum  ;Get checksum value
        jr z,intelLoader    ;Line is processed and okay, get next line
        ret                 ;Exit with zero flag not set (load error)

intelCheckSum:
        call getHexByte     ;Convert ASCII to Byte (Checksum)
        ld a,c              ;Final Checksum is zero if okay
        or a                ;set zero flag
        ret                 ;get next line or exit

        ;Get ASCII character from FTDI AND convert it to a byte
        ;IE: "D3" -> 0D3H
getHexByte:
        call getHexChar     ;Get first Hex character from FTDI
        rlca                ;Move lower nibble
        rlca                ;(first character)
        rlca                ;to upper
        rlca                ;nibble in A
        ld d,a              ;store it in D
        call getHexChar     ;Get second Hex character from FTDI
        or d                ;make a byte
        ;add byte to checksum
        push af             ;save AF
        add a,c             ;add existing checksum C to current byte
        ld c,a              ;load total back to C
        pop af              ;restore AF
        ret
getHexChar:
        call rxByte         ;Get Byte from FTDI USB driver
        bit 6,a             ;is the chracter 0-9 or A-F?
        jr z,$+4            ;Its 0-9 skip A-F adjustment
        add a,9             ;add 9 to fix A-F
        and 0FH             ;mask out high nibble and convert to binary
        ret

; SIO Hex Dump.  Transfer data on the TEC to a serial terminal
; Destroys: A,HL,DE,BC
dataToSerial:
        call getToFrom      ;collect parameters
        call readyToTransmit ;set up serial for transmit
; transmits data between DATA_FROM / DATA_TO to the serial terminal.  Can
; be called externally provided DATA_FROM/TO (08C0-08C3) are populated.
sendToSerial:
        ld a,01000000B      ;bit 6 of 7seg digits
        out (DIGITS),a      ;set transmit line high
        ex de,hl            ;save HL
        ld hl,2000H         ;small
        call timeDelay      ;delay
        ex de,hl            ;HL = start address
sendLoop:
        ld a,(hl)           ;load A with data
        call txByte         ;transmit it to FTDI
        cpi                 ;inc HL, dec BC
        jp pe,sendLoop      ;repeat until BC=0
        ret                 ;all done
dataRangeParams:        
        .db 2                           ;Three parameters
        .db "= Enter Parameters =",0    ;Parameter title
        .db "From Address:",0           ;Text and Address
        .dw DATA_FROM
        .db "To Address:",0             ;Text and Address
        .dw DATA_TO

; SIO receive data.  Receive binary data from FTDI
dataFromSerial:
        call getToFrom      ;collect parameters
receiveFromSerial:
        call rxByte         ;get byte from serial
        ld (hl),a           ;load byte into HL
        cpi                 ;inc HL, dec BC
        jp pe,receiveFromSerial  ;repeat until BC=0
        ret                 ;all done

; Collect Address To and From information from user via the LCD interface
; Stores From at DATA_FROM (08C0H) and To at DATA_TO (08C2H)
; Output: HL = start address
;         BC = length of end - start+1
; Note: if end < start (error) then call error handler
; Destroys: DE
getToFrom:
        ld hl,dataRangeParams
        call paramDriver    ;collect parameters
        ld hl,DATA_FROM     ;check parameters
        call checkStartEnd  ;
        ret nc              ;All good, continue
        pop hl              ;remove call return from stack
        jp displayError     ;display error if end < start

; Send Disassembly to serial terminal
; Destroys: All
assemblyToSerial:
        call getToFrom      ;collect parameters
; prints assemblybetween DATA_FROM / DATA_TO to the serial terminal.  Can
; be called externally provided DATA_FROM/TO (08C0-08C3) are populated.
sendAssembly:
        call readyToTransmit ;set up serial for transmit
        ld hl,(DATA_FROM)   ;get start address
        ld (DISFROM),hl     ;save start in DIS_FROM
assemblyLoop:
        call disStart       ;generate Disassembly
        ld hl,DISLINE1      ;get string
        ld b,38             ;38 characters
        ld a,(hl)           ;load A with data
        call txByte         ;transmit it to FTDI
        inc hl              ;move to next location
        djnz $-5            ;repeat 38 times
        ld a,0DH            ;carriage return
        call txByte         ;send CR
        ld hl,(DISFROM)     ;get current start
        ld de,(DATA_TO)     ;get end address
        or a                ;clear carry
        sbc hl,de           ;check difference between
        add hl,de           ;start and end address
        jr c,assemblyLoop   ;if not zero then loop
        ret                 ;all done

; Send a traditional HEX dump to the serial terminal.
; Input: none
; Output: text to  serial
; Destroy: All
hexDumpToSerial:
        call getToFrom      ;collect parameters
        call readyToTransmit ;set up serial for transmit
sendHex:
        push hl             ;store current address
        push bc             ;store byte count
        pop hl              ;HL = BC
        ld de,-16           ;load DE with minus 16
        add hl,de           ;reduce hl by 16
        ld e,16
        jr c,hexMore
        push bc
        pop hl
        ld e,c
hexMore:
        ex (sp),hl          ;get current address, store bytes remaining
        ld b,e              ;byte count
        ld de,DATA_ROW      ;point to Data Entry RAM
        call genDataDump    ;fill DE with data dump line
        push hl             ;store next address
        ld hl,DATA_ROW      ;make HL = start or data row
hexTextloop:
        ld a,(hl)           ;get ASCII
        inc hl              ;move to next address
        or a                ;is it zero
        jr z,skipHex        ;yes, skip sending to serial
        call txByte         ;send byte to serial
        jr hexTextloop      ;repeat
skipHex:
        ld a,0DH            ;carriage return
        call txByte         ;send CR
        pop de              ;restore next start address
        pop bc              ;restore bytes remaining
        ld hl,(DATA_TO)     ;get end address
        or a
        sbc hl,de           ;check difference
        ret c               ;return if all done
        ex de,hl            ;set hl to new start address
        jr sendHex          ;repeat until all bytes are printed

; Display 7Seg Message.  Display data on the Seven Segment Display and 
; maintain display until a key is pressed
; Input: HL = 6 byte Segment Data pointer
; Destroy: ALL
display7Segs:
        ld de,DISP_BUFF     ;set destination to display buffer
        ld bc,6             ;size bytes
        ldir                ;fill display buffer with text
        call scanKeys       ;check for key pressed
        ld a,(KEY_PRESS)    ;is a key currently pressed?
        or a                ;is it zero (pressed)
        jr z,$-7            ;repeat until key is released
displayLoop:
        call scanDisplayBuff ;Multiplex the seven segments
        call scanKeys       ;Scan for key press
        jr nz,displayLoop   ;Repeat scan until key pressed
        ret

; Compare strings utility
; HL = source
; DE = target
; B = #bytes to compare (up to 256)
;
; Z = compare match
; NZ = compare fail
;
; destroys HL, DE, A, BC
stringCompare:
        ld a,(hl)           ;Load Source into A
        ld c,a              ;Store in C
        ld a,(de)           ;Load compare into A
        cp c                ;A==C ?
        ret nz              ;No - so edxt with Z flag reset
        inc hl              ;Yes - move on to next byte
        inc de              ;Next byte
        djnz stringCompare  ;Loop around till B=0 (check whole string)
        ret                 ;Matched, so return with Z flag set

; Defaults to check for double ASCII space
stringZeroSpace:
        ld a," "            ;Space and fall through.         
; Place a zero at then end of a string.  Routine checks for two bytes
; in a row that are the same and when found, will place a zero in the first 
; byte found.  If no byte found within 20 characters then exit with no update
; Input: A = byte value to check, usually 0 or ' '
;        HL = pointer to ASCII string
; Output: Zero Set = Updated HL
;         Zero not set = No match found
; Destroys: A
stringZero:
        push bc             ;save BC
        push hl             ;save HL
        ld bc,20            ;twenty goes (LCD width)
sZ1:
        cpir                ;find a matching byte
        jr nz,sZ2           ;if non zero here, no byte match and BC=0, just exit
        cp (hl)             ;compare with next value
        jr nz,sZ1           ;Nope, try again
        dec hl              ;go back to first match
        xor a               ;set A=0
        ld (hl),a           ;make it zero
sZ2:
        pop hl              ;restore HL
        pop bc              ;restore BC
        ret

; Count the number of ASCII spaces in a zero terminated string
; Input: HL = pointer to string
; Output: A = number of spaces
stringSpaces:
        push bc             ;save BC
        push hl             ;save HL
        ld c,0              ;counter
strSpLoop:
        ld a,(hl)           ;get value
        or a                ;is it zero?
        jr nz,strSpCheck    ;no
        ld a,c              ;set return value
        pop hl              ;restore HL
        pop bc              ;restore BC
        ret                 ;exit
strSpCheck:
        cp " "              ;is it a space
        inc hl              ;move to next address
        jr nz,strSpLoop     ;loop again if not space
        inc c               ;increase space counter
        jr $-3              ;loop again, c = non zero

; Convert HL to ASCII string. IE: 2CH -> "2C"
; Input: HL = value to convert
;        DE = address of string destination
; Output: DE = address one after last ASCII entry
; Destroys: A
HLToString:
        ld a,h              ;get H
        call AToString      ;convert to String
        ld a,l              ;get L

; Convert A to ASCII string
; Input: A = byte to convert
;        DE = address of string destination
; Output: DE = address one after last ASCII entry
; Destroys: A
AToString:
        push af             ;save AF
        rra                 ;move high
        rra                 ;nibble to low nibble
        rra
        rra
        call lowNibToString ;get lower nibble and save in DE
        pop af              ;restore AF
lowNibToString:
        and 0FH             ;mask out high nibble
        add a,90H           ;convert to
        daa                 ;ASCII
        adc a,40H           ;using this
        daa                 ;amazing routine
        ld (de),a           ;save in DE
        inc de              ;move to next DE
        ret                 ;exit back

; convert register A to ASCII. IE: 2CH -> "2C"
; Input: A = byte to convert
; Output: HL = two byte ASCII string
; Destroys: A
regAToASCII:
        push af             ;save AF
        rrca                ;move high 
        rrca                ;nibble to
        rrca                ;low
        rrca                ;nibble
        call nibble2ASCII   ;call nib to ASCII routine
        ld h,l              ;move upper nibble to H
        pop af
nibble2ASCII:
        and 0FH             ;mask out high nibble
        add a,90H           ;convert to
        daa                 ;ASCII
        adc a,40H           ;using this
        daa                 ;amazing routine
        ld l,a              ;store in L
        ret                 ;exit

; Generate data dump in ASCII.  Print Address and then C number of bytes
; Input: B = number of bytes to display
;        HL = start address of data dump
;        DE = address of string destination
; Output: DE = zero terminated address one after last ASCII entry
;           IE: "4000: 23 34 45 56 78 9A BC DE",0
; Destroys: A, HL (moves to next address after last byte)
genDataDump:
        push bc             ;save BC
        call HLToString     ;convert HL to address in ASCII
        ld a,":"            ;set A = colon
        ld (de),a           ;write a colon after address
        inc de
dataDumpLoop:
        ld a," "            ;set A = space
        ld (de),a           ;write a space
        inc de
        ld a,(hl)           ;get byte at HL
        call AToString      ;convert A to string
        inc hl              ;move HL to next address
        djnz dataDumpLoop   ;if not zero get next byte
        xor a               ;set A = 0
        ld (de),a           ;terminate string with zero
        pop bc              ;restore BC
        ret

; Check start and end address difference.
; Input: HL = address location of START value
;        HL+2 = address location of END value
; Output: HL = start address
;         BC = length of end-start
;         Carry = set if end is less than start
; Destroys: DE
checkStartEnd:
        ld e,(HL)           ;move start
        inc hl              ;address into DE
        ld d,(HL)           ;move end
        inc hl              ;address into HL
        ld c,(HL)
        inc hl
        ld h,(HL)
        ld l,c
        or a                ;clear carry
        sbc hl,de           ;is END > START (it should be)
        ld c,l              ;move byte count
        ld b,h              ;into BC
        inc bc              ;if END < START then carry is set
        ex de,hl            ;HL is start address
        ret

; Block Move generic routine.  Move a block of code between start and end
; to destination.
; NOTE: Must have COPY_START,COPY_END and COPY_DEST filled
; Destroys HL, DE, A, BC
blockMove:
        ld hl,COPY_START    ;get start location
        call checkStartEnd  ;check start < end
        jp c,displayERROR   ;if carry is set exit and error
        ld de,(COPY_DEST)   ;load DE with destination address
        sbc hl,de           ;see if destination is < or > than start
        jr nc,mvup          ;jump if start > destination
        ex de,hl            ;add byte count to destination
        add hl,bc
        dec hl
        ex de,hl
        ld hl,(COPY_END)    ;get end address
        lddr                ;copy End to Start going backwards
        inc de
        ret                 ;move done
mvup:
        add hl,de           ;make HL the difference between start and dest
        ldir                ;copy Start to End going forwards
        dec de
        ret                 ;move done
blockMoveParams:        
        .db 3                           ;Three parameters
        .db "= Enter Parameters =",0    ;Parameter title
        .db "Start Address:",0          ;Text and Address
        .dw COPY_START
        .db "End Address:",0            ;Text and Address
        .dw COPY_END
        .db "Dest. Address:",0          ;Text and Address
        .dw COPY_DEST

; Move a block of code AND update all absolute jumps and calls.
; Destroys HL, DE, A, BC
smartCopy:
        ld hl,blockMoveParams
        call paramDriver    ;collect parameters
smartCopyDirect:
        call blockMove      ;move block
        ld hl,(COPY_DEST)   ;put destination in HL
        ld de,(COPY_START)  ;put start in DE
        or a                ;clear carry
        sbc hl,de           ;get offset from start and destination
        ld (COPY_CORR),HL   ;save offset in correction
        ld hl,(COPY_END)    ;put end in HL
        ld de,(COPY_START)  ;put start in DE
        or a                ;clear carry
        sbc hl,de           ;get byte count between start and end
        inc hl              ;correct HL to real count
        ld de,(COPY_DEST)   ;put destination in DE
        add hl,de           ;find end of destination block
        ld (COPY_EBLK),hl   ;save it
        ld (COPY_PTR),de    ;save destination to pointer
checkInst:
        ld hl,(COPY_PTR)    ;get pointer
        ld a,(hl)           ;get instruction
        call getInstLen     ;get instruction length in C
        ld a,c              ;get instruction count
        cp 4                ;is it 4 bytes long?
        jr nz,check3        ;no, check 3
        ld a,(hl)           ;get instruction
        cp 0EDH             ;is it extended instruciton?
        jr z,fourByteAddr   ;yes, modify address
        and 0DFH            ;check fo IX
        cp 0DDH             ;and IY
        jr nz,nextInst      ;skip, as its something else
        inc hl              ;move to second byte
        ld b,(hl)           ;get instruction
        dec hl              ;move back one byte
        ld a,b              ;check A
        and 0CFH            ;is it 21H?
        cp 01H              ;
        jr z,fourByteAddr   ;yes, modify address
        ld a,b              ;check A
        and 0E7H            ;is it 22H
        cp 22H              ;or 2AH?
        jr nz,nextInst      ;no, skip instruction
fourByteAddr:
        inc hl              ;move to make 3 bytes
        ld (COPY_PTR),hl    ;save destination to pointer
        jr $+4              ;continue
check3:
        cp 3                ;is it 3 bytes long?
        jr nz,nextInst      ;no, just get next instruction
        ld a,(hl)           ;get instruction
        and 0DFH            ;check fo IX
        cp 0DDH             ;and IY
        jr z,nextInst       ;skip, as its something else
        ld a,(hl)           ;get instruction
        push hl             ;store instruction
        pop de              ;put in DE
        inc hl              ;put address
        ld c,(hl)           ;in
        inc hl              ;BC
        ld b,(hl)
        ld hl,(COPY_START)  ;load HL with start address
        dec hl
        or a                ;clear carry
        sbc hl,bc           ;get target difference
        jr nc,targetSkip    ;jump if target is less than start
        ld hl,(COPY_END)    ;load HL with end address
        or a                ;clear carry
        sbc hl,bc           ;get target difference
        jr c,targetSkip     ;jump if target is higher than end
        ld hl,(COPY_CORR)   ;get correction factor
        add hl,bc           ;adjust target with correction
        ex de,hl            ;put new address in DE
        inc hl              ;and store
        ld (hl),e           ;it
        inc hl              ;back
        ld (hl),d           ;to jump/call instruction
targetSkip:
        ld hl,(COPY_PTR)    ;get pointer
        inc hl              ;increase to next instruction
        inc hl
        inc hl
endTest:
        ld (COPY_PTR),hl    ;save new pointer
        ld de,(COPY_EBLK)   ;get end block
        or a                ;clear carry
        sbc hl,de           ;test for finish
        jr c,checkInst      ;not at end, check next instruction
        ret                 ;end, just return
nextInst:
        inc hl              ;move to next byte
        dec c               ;until new instruction
        jr nz,nextInst
        jr endTest          ;jump to end test

; Instruction byte count routine
; Input: HL = address of first op code
; Return: C = instruction length
;         Carry Set = instruction is a RET,JP,CALL,RST
; Destroys A, B
getInstLen:
        ld c,4              ;set length to longest instruction
        ld a,(hl)           ;put first op code in A
        inc hl
        ld b,(hl)           ;put second op code in B
        dec hl              ;restore HL
        and 0DFH
        cp 0DDH             ;is it an IX/IY instruction
        jr nz,getIns2
        ld a,b
        cp 0CBH             ;is it a IX/IY Bit instruction
        jr nc,getIns1     
        cp 36H
        ret z
        cp 21H
getIns1:
        ret z
        and 0F7H
        cp 22H
        ret z
        jr getIns3
getIns2:
        ld a,(hl)
        cp 0EDH             ;is it an Misc Instruction
        jr nz,getIns4
        ld a,b
        and 0C7H
        cp 43H              ;does it have a 2 byte address?
        ret z
        or a
        dec c
        dec c
        ret
getIns3:
        dec c
        ld a,b
        and 0B8H
        cp 30H
        ret z
        ld a,b
        and 06H
        cp 06H
        ret z
        dec c
        ld a,b
        cp 0E9H
        scf
        ret z
        ccf
        ret
getIns4:
        dec c
        ld a,(hl)
        and 0CFH
        cp 01H
        ret z
        ld a,(hl)
        and 0E7H
        cp 22H
        ret z
        ld a,(hl)
        cp 0C3H
        scf
        ret z
        cp 0CDH
        scf
        ret z
        and 0C7H
        cp 0C2H
        scf
        ret z
        cp 0C4H
        scf
        ret z
        dec c
        cp 06H
        ret z
        cp 0C6H
        ret z
        dec c
        scf
        ret z
        ld a,(hl)
        and 0F7H
        ret z
        inc c
        ld a,(hl)
        and 0E7H
        cp 0C3H
        ret z
        and 0C7H
        scf
        ret z
        dec c
        ld a,(hl)
        cp 0E9H
        scf
        ret z
        cp 0C9H
        scf
        ret z
        and 0C1H
        cp 0C0H
        scf
        ret z
        ccf
        ret

; Calculate actual disassembly address from CEL
; Output: HL = Disassembly start address
; Destroy: A,DE
; Updates DIS_ADDR
calcDisAddress:
        ld hl,(CEL)         ;get CEL
        ld bc,0FFF9H        ;set BC = -7
        add hl,bc           ;modify HL with offset
        jr c,disTestLoop    ;if HL <=3 then fix HL
        ld hl,0
disTestLoop:
        ld (DIS_ADDR),hl    ;update DIS_ADDR with current HL
        ld (DISFROM),hl     ;Store it in the disassembler start address
        call disStart       ;Work out next valid from address
        ld de,(CEL)         ;get CEL
        ex de,hl            ;swap HL,DE
        or a
        sbc hl,de           ;Calculate CEL-DISFROM
        ex de,hl
        jp p,disTestLoop    ;If DISFROM < CEL then
        ld hl,(DIS_ADDR)    ;Store HL with previous valid disassembly address
        ret

; Just move a block from A to B with no 2 byte address updates
; Destroys HL, DE, A, BC
dumbCopy:
        ld hl,blockMoveParams
        call paramDriver    ;collect parameters
        jp blockMove        ;move block

; Display ERROR/PASS on the 7Segs and wait for key press
displayError:
        or a                ;clear carry
        ld hl,errorText     ;error text
        jp display7Segs     ;display on 7Segs and exit when key is pressed
displayPass:
        ld hl,passText      ;pass text
        jp display7Segs     ;display on 7Segs and exit when key is pressed

; Key scan routine for the Matrix Keyboard.  This routine detects up to
; two key presses at the same time.  Key values stored in DE
; Note: Must be called repetatively
; Input: None
; Output: E = Key pressed between 00H-3FH (0-64)
;         D = Second key, FF=no key, 00=shift, 01=Ctrl, 02=Fn
;         zero flag set if a key is pressed or combination valid
matrixScan:
        ld l,0FFH           ;Row value accumulator. Add 8 for each ROW
        ld de,0FFFFH        ;Return Values if no key is pressed
        LD bc,0FEFEH        ;Port = C, A8-A15 = B. B loaded with only A8 = 0 to start.
kLine:
        in a,(c)            ;Check data bus for Port C and high address B
        cpl                 ;Invert to check for zero
        and 0FFH            ;Masking of bits would happen here, but we use all 8
        jr z,kDone          ;If Zero, no key press for Address line
        ld h,a              ;Save key(s) pressed data in H
        ld a,l              ;Load A with the current ROW count*8
kBits:
        inc a               ;Add one until data bit found
        srl h               ;Shift H right until bit is detected
        jr nc,kBits         ;If Carry is not set, shift again
        ld d,e              ;Load first key detected into D
        ld e,a              ;Store key detected
        jr nz,kBits         ;Keep going until all bits are checked.
kDone:
        ld a,8              ;
        add a,l             ;Increase L by 8 for each ROW checked
        ld l,a
        rlc b               ;Move to next address line
        jr c,kLine          ;if more address lines needed repeat key check

        ld a,e              ;Check for any key press
        cp 40H              ;Is it a valid key?
        ret nc              ;No, exit with Zero flag false

        ld a,d              ;Check if 1 or two key pressed
        inc a
        ret z               ;If one key exit, D=FF, E=key
        ;Check for Shift/Ctrl/Fn keys pressed
        dec a
        ret z               ;Exit zero if Shift pressed
        dec a
        ret z               ;Exit zero if Control pressed
        dec a
        ret                 ;Exit zero if Function pressed or non zero for anything else

; Joystick port scan routines.  This routine will return a value based on the
; movement / button of the joystick or any combination: IE: UP+DOWN = 03H
; Note: Must be called repetatively
; Input: None
; Output: A = Joystick return value between 00H-5FH (0-95)
;       01H = Up        10H = Fire 2
;       02H = Down      20H = Comm2 (Pin 9)
;       04H = Left      40H = Fire 1
;       08H = Right     80H = Fire 3
;         zero flag set if no joystick value returned
; Destroy: none
joystickScan:
        push bc             ;save BC
        ld bc,0F7FEH        ;Port = FE, B is only loaded with A11 = 0 (Joystick Line)
        in a,(c)            ;read joystick port
        cpl                 ;Invert to check for zero
        and 0FFH            ;Mask and set zero flag if A=0
        pop bc              ;restore BC
        ret                 ;Exit with A set and Zero flag

; Breakpoint Entry.  Display flags and most registers on the LCD Screen.
; Press GO to continue executing, AD to do a soft reset.  Entry to this
; routine can be done by RST 30H or 0F7H
breakPoint:
        call saveRegisters  ;save all current registers to BP stack
        call saveLCD        ;save contents of DDRAM into RAM
        ld b,01H            ;clear LCD
        call commandToLCD   ;update LCD
        ; display register text on LCD
        ld de,breakPointRows ;LCD row table
        ld hl,breakPointRegs ;LCD resgister text
        ld c,8              ;eight registers
bpText:
        ld a,(de)           ;get row position
        ld b,a              ;move to B
        call commandToLCD   ;update LCD
        inc de
        call stringToLCD    ;output text (HL) to LCD
        dec c               ;next register
        jr nz,bpText        ;repeat for all 8 registers

        ;display register values next to text
bpData:
        ld de,breakPointRows ;LCD row table
        ld hl,BP_BASE_SP    ;register memory location
        ld c,6              ;six registers
        call bpPrintData
        ld hl,BP_PC         ;start at PC
        ld c,2              ;two registers
        call bpPrintData

        ;display flags
        ld a,(BP_BASE_SP)   ;register AF
        ld c,a
        ld de,breakPointFlagRows
        ld hl,breakPointFlags
bpFlagRow:
        ld a,(de)
        or a
        jr z,bpQuery        ;No more, go to key query
        ld b,a              ;move to B
        call commandToLCD   ;update LCD
        inc de
        ld b,2              ;two flags
bpFlagCol:
        ld a,(hl)
        inc HL
        rlc c
        jr c,$+4            ;Skip lower case
        add a,20H           ;Make lowercase
        call charToLCD      ;send character to LCD
        djnz bpFlagCol
        jr bpFlagRow

        ;handle keypress and exit. GO = continue, AD = Exit
bpQuery:
        ld de,breakText     ;set display buffer to Breakpoint display
        call scanSegments   ;Multiplex the seven segments
        call scanKeys       ;Scan for key press
        jr nz,bpQuery       ;Repeat scan until key pressed
        jr nc,bpQuery       ;Skip if not new key
        cp K_GO             ;is key GO
        jr nz,$+9           ;No, check if AD key pressed
        call restoreLCD     ;restore content of LCD from RAM
        call restoreRegisters ;clean up stack and exit back to code execution
        ret                 ;return back to last execution location
        cp K_ADDR           ;is it the AD key (Exit back to monitor)
        jr nz,bpQuery       ;no, keep scanning
        ld sp,STACK_TOP     ;reset the Hardware Stack to top of stack in RAM
        jp softBoot         ;just do a softboot and exit

bpPrintData:
        ld a,(de)           ;get row position
        add a,3             ;move three to the right
        ld b,a              ;move to B
        call commandToLCD   ;update LCD
        inc de              ;move to next postion
        push de             ;save DE
        ex de,hl
        ld b,2
        inc de
bpDataOut:
        ld a,(de)
        call regAToASCII
        ld a,h
        call charToLCD      ;send character to LCD
        ld a,l
        call charToLCD      ;send character to LCD
        dec de
        djnz bpDataOut
        inc de
        inc de
        inc de
        ex de,hl
        pop de
        dec c
        jr nz,bpPrintData
        ret
        
; Save registers to Break Point stack.  Registers are saved in memory in
; this order: AF,HL,BC,DE,IX,IY,AF',HL',BC',DE',PC,SP
; Input: none
; Destroys: nothing
; Note: need to set BP_PC prior to calling this routine to set actual program counter
; Routine is to be called from previous CALL to get Actual SP. SP=SP-4.
; IE: Actual Code > RST 30H > saveRegisters. 
saveRegisters:
        ld (BP_HL),hl       ;save HL first so to use HL in routine
        push af             ;store AF
        pop hl              ;HL = AF
        ld (BP_BASE_SP),hl  ;save AF as flags get corrupt below
        ld hl,4             ;set HL to calling SP
        add hl,sp           ;HL = SP+4
        ld (BP_ORIG_SP),hl  ;save actual SP
        ld sp,BP_REGS       ;set SP to use Break Point stack
        ex af,af'           ;start saving registers
        exx
        push de
        push bc
        push hl
        push af
        ex af,af'
        exx
        push iy
        push ix
        push de
        push bc
        ld hl,(BP_HL)       ;restore original hl
        ld sp,(BP_ORIG_SP)  ;restore hardware stack
        dec sp              ;to 
        dec sp              ;acutal 
        dec sp              ;position prior
        dec sp              ;to calling this routine
        ret

; Restore registers.  Replace CPU registers with values stored in the BreakPoint buffer
; A call to saveRegisters is to be called prior
; Input: none
; Output: Updates registers AF,HL,BC,DE,IX,IY,AF',HL',BC' and DE'
restoreRegisters:
        ld (BP_ORIG_SP),sp
        ld sp,BP_BASE_SP
        pop af
        pop hl
        pop bc
        pop de
        pop ix
        pop iy
        ex af,af'
        exx
        pop af
        pop hl
        pop bc
        pop de
        ex af,af'
        exx
        ld sp,(BP_ORIG_SP)
        ret

; Save LCD screen contents.  Copy LCD DDRAM contents to RAM location BP_LCD.  
; Input: none
; Output: Writes 80 bytes (20x4) of LCD DDRAM to BP_LCD address (08B8H-0908H)
; Destroys: A, BC, HL
saveLCD:
        ld b,LCD_ROW1       ;Set DDRAM address counter to Row 1
        call commandToLCD   ;Send instruction to LCD
        ld hl,BP_LCD        ;set HL to LCD RAM location
        ld bc,40*100H+LCD_DATA ;40 bytes to read, Port LCD_DATA
        rst 28H             ;ensure LCD isn't busy
        ini                 ;read port C, into (HL), inc HL, dec B
        jr nz,$-3           ;Do unitl B=0

        ld b,LCD_ROW2       ;Set DDRAM address counter to Row 2
        call commandToLCD   ;Send instruction to LCD
        ld b,40             ;40 bytes to read
        rst 28H             ;ensure LCD isn't busy
        ini                 ;read port C, into (HL), inc HL, dec B
        jr nz,$-3           ;Do unitl B=0
        ret

; Restore LCD screen contents.  Copy RAM location BP_LCD to LCD DDRAM
; A call to saveLCD is to be called prior
; Input: none
; Output: Updates LCD with values at BP_LCD (08B8H-0908H)
; Destroys: A, BC, HL
restoreLCD:
        ld b,LCD_ROW1       ;Set DDRAM address counter to Row 1
        call commandToLCD   ;Send instruction to LCD
        ld hl,BP_LCD        ;set HL to LCD RAM location
        ld bc,40*100H+LCD_DATA ;40 bytes to read, Port LCD_DATA
        rst 28H             ;ensure LCD isn't busy
        outi                ;write to port C, from (HL), inc HL, dec B
        jr nz,$-3           ;Do unitl B=0

        ld b,LCD_ROW2       ;Set DDRAM address counter to Row 2
        call commandToLCD   ;Send instruction to LCD
        ld b,40             ;40 bytes to read
        rst 28H             ;ensure LCD isn't busy
        outi                ;write to port C, from (HL), inc HL, dec B
        jr nz,$-3           ;Do unitl B=0
        ret

; Display System Control Latch Byte on LCD Screen
; Input: none
; Destroy: all
displaySystemCtrl:
        call beep           ;indicate key press
        ld b,01H            ;clear LCD
        call commandToLCD   ;update LCD
        ; display system control text on LCD
        ld de,sysCtrlRows;LCD row table (same as BP)
        ld hl,sysCtrlText   ;LCD system control text
        ld b,8              ;eight bits
        ld a,(SYS_MODE)     ;get value on system control latch
        ld c,a              ;store in C
scText:
        ld a,(de)           ;get row position
        push bc             ;save BC
        ld b,a              ;move to B
        call commandToLCD   ;update LCD
        pop bc              ;restore BC
        inc de
        call stringToLCD    ;output text (HL) to LCD
        ld a,c              ;get system contrl
        and 01H             ;get last bit
        push af             ;uggg
        ld a,b              ;messy 
        cp 8                ;to set 
        jr nz,$+7           ;shadow 
        pop af              ;properly
        xor 01H
        jr $+3
        pop af
        add a,"0"           ;convert to ASCII
        rrc c               ;rotate sys control byte
        call charToLCD      ;send to LCD
        djnz scText         ;repeat for all 8 registers
        ;wait for keyboard input to exit
        rst 08H             ;wait for key press
        ret

; Serial Enable.  Sets the TX line to high ready for serial transfer
; Input: none
; Destroys: A
serialEnable:
        ld a,40H            ;Serial TX bit
        out (DIGITS),a      ;Set it high
        ld a,44H            ;Set Tri colour LEDs to Disco Blue
        out (SEGS),a        ;output it
        ret

; Serial Disable.  Sets the TX line to low disabling serial transfer
; Input: none
; Destroys: A
serialDisable:
        xor a               ;clear A
        out (DIGITS),a      ;Set it segment display off
        out (SEGS),a        ;Clear segment leds
        ret

; Menu Initialise.  Set a custom user menu on the LCD. 
; Input: HL = Pointer to Menu configuration.
; Destroys: A, HL
menuInit:
        xor a               ;clear A
        ld (MENU_POS),a     ;set menu position to first
        ld (MENU_SEL),a     ;set first item to be selected
        ld a,(hl)           ;get menu count
        ld (MENU_CNT),a     ;save menu count
        inc hl
        ld (MENU_CFG),hl    ;store menu configuration
        ret

; Menu Draw routine.  Title, then menu items from MENU_POS
menuDraw:
        ld b,01H            ;clear LCD instruction
        call commandToLCD   ;update LCD
        ld hl,(MENU_CFG)    ;load menu config
        call stringToLCD    ;send Title to LCD
        ld a,(MENU_POS)     ;get current menu selection
        call menuIndex      ;set HL to menu config at index A
        ld c,3              ;three rows
        ld a,(MENU_CNT)     ;get menu count
        cp c                ;is it 3 or less?
        jr nc,$+3           ;yes, skip setting b=count
        ld c,a              ;set rows to max count
        ld de,LCDBaseRows+1 ;LCD rows 2,3,4
drawLoop:
        ld a,(de)           ;get row value
        ld b,a              ;set B as LCD row
        inc b               ;move one to the right
        call commandToLCD   ;update LCD
        call stringToLCD    ;write menu item
        ld a,(MCB)          ;get MCB
        and MCB_MEN_PAR     ;check to see if menu or parameter structure
        jr z,drawHLSkip     ;menu so skip HL draw
        ld a,(de)           ;get row value
        add a,16            ;right justify
        ld b,a              ;set B as LCD row/column
        call commandToLCD   ;update LCD                
        push hl             ;save HL
        ld a,(hl)           ;store ram
        inc hl              ;address
        ld h,(hl)           ;back into
        ld l,a              ;HL
        inc hl              ;move to high byte
        ld b,2              ;type bytes
drawHL:
        ld a,(hl)           ;get byte
        push hl             ;save HL
        call regAToASCII
        ld a,h
        call charToLCD      ;send character to LCD
        ld a,l
        call charToLCD      ;send character to LCD
        pop hl              ;restore HL
        dec hl              ;move to low byte
        djnz drawHL         ;do next byte
        pop hl              ;restore HL
drawHLSkip:
        inc hl              ;skip jump
        inc hl
        inc de              ;move to next row
        dec c               ;get next row
        jr nz,drawLoop      ;if any
        ;draw pointer
        ld a,(MENU_POS)     ;get menu text pos
        ld b,a
        ld a,(MENU_SEL)     ;get selection
        sub b               ;A = 0,1 or 2
        ld de,LCDBaseRows+1 ;LCD rows 2,3,4
        add a,e             ;index DE (same page!)
        ld e,a
        ld a,(de)           ;get row index
        ld b,a
        call commandToLCD   ;update LCD
        ld a,MENU_PTR       ;display ->
        jp charToLCD        ;display it and exit

; Index menu configuration with A
; Input: A = index
; Output: HL = position of menu entry text.
menuIndex:
        ld b,a              ;save index
        ld hl,(MENU_CFG)    ;get configuration
        ld a,(hl)           ;skip menu title
        inc hl          
        or a                ;is it zero
        jr nz,$-3           ;repeat until zero found
        ld a,b              ;is index zero?
        or a                ;yes
        ret z               ;HL in correct spot
indexLoop:
        ld a,(hl)           ;skip menu entry
        inc hl          
        or a                ;is it zero
        jr nz,$-3           ;repeat until zero found
        inc hl              ;move to next menu entry
        inc hl
        djnz indexLoop      ;keep going until done
        ret

; Menu driver for external applications.  Creates a selectable custom menu
; Keys: Go = Select menu item, AD = Exit Menu, +/- = Navigate menu
; Input: HL = Pointer to Menu configuration. (See Note)
; Destroys: A, HL
; Note: Menu configuration is as follows.  All strings are ZERO terminated!
; <Menu Entries>, <Menu Text Title>, [<Menu Text Label>, <Menu Routine Address>]+
; EG: .db 2             ;Two menu items
;     .db "Games",0     ;Menu title
;     .db "TEC Invaders",0  ;Text and Routine
;     .dw invaders
;     .db "TEC Maze",0  ;Text and routine
;     .dw maze
menuDriver:
        call menuInit       ;Initialise the internal memory with menu config
        ld hl,MCB           ;set MCB
        set 3,(hl)          ;into LCD mode
        pop hl              ;pop return address of rst 10
        pop hl              ;pop return address of GO call
        jp setLCD           ;hook into monitor menu controller

; Parameter data entry driver.  Creates a list of editable two byte parameters
; utilising the menu handler.
; Keys: Go = Continue, AD = Exit, +/- = Navigate, 0-F = enter values
; Input: HL = Pointer to Parameter configuration. (See Note)
; Note: Parameter configuration is as follows.  All strings are ZERO terminated!
; Parameter text can be no longer than 14 characters
; <No. of Entries>, <Parameter Title Text>, [<Param Text Label>, <Param RAM Address>]+
; EG: .db 3             ;Three parameters
;     .db "= Enter Parameters =",0     ;Parameter title
;     .db "Start Address:",0  ;Text and Address
;     .dw COPY_START
;     .db "End Address:",0  ;Text and Address
;     .dw COPY_END
;     .db "Dest. Address:",0  ;Text and Address
;     .dw COPY_DEST
paramDriver:
        call menuInit       ;Initialise the internal memory with param config
        ld hl,MCB           ;set MCB
        set 3,(hl)          ;into LCD mode
        set 5,(hl)          ;and Parameter Entry mode
        jp setLCD           ;hook into monitor menu controller    

; Get Caps lock state
; Input: none
; Output: A = caps lock state; 0 = off, CAPSLOCK = on
getCaps:
        ld a,(SYS_MODE)     ; fetch current value
        and CAPSLOCK        ; return caps lock bit only
        ret

; Get SHADOW state
; Input: none
; Output: A = shadow state; 0 = off, SHADOW = on
getShadow:
        ld a,(SYS_MODE)     ; fetch current value
        and SHADOW          ; return SHADOW bit only
        xor SHADOW          ; flip bit becuase active low
        ret
        
; Get PROTECT state
; Input: none
; Output: A = caps lock state; 0 = off
getProtect:
        ld a,(SYS_MODE)     ; fetch current value
        and PROTECT         ; return PROTECT only
        ret

; Get EXPAND state
; Input: none
; Output: A = caps lock state; 0 = off
getExpand:
        ld a,(SYS_MODE)     ; fetch current value
        and EXPAND          ; return EXPAND bit only
        ret

; Set Caps lock state
; Input: A = Desired caps lock state; 0 = off, CAPSLOCK = on
; Destroy: A
setCaps:
        push bc
        and CAPSLOCK        ; ensure only correct bit is accepted
        ld b,a              ; save A in B
        ld a,(SYS_MODE)     ; get current state
        and CAPSLOCK-1      ; clear bit
updateMode:
        or b                ; set new bit state from B
        out (SYS_CTRL),a
        ld (SYS_MODE),a
        pop bc
        ret

; Set SHADOW state
; Input: A = Desired SHADOW state; 0 = off, SHADOW = on
; Destroy: A
setShadow:
        push bc
        and SHADOW          ; ensure only correct is accepted
        xor a               ; flip bit because active low
        ld b,a              ; save A in B
        ld a,(SYS_MODE)     ; get current state
        and -SHADOW-1       ; clear bit
        jr updateMode       ; set mode and exit

; Set PROTECT state
; Input: A = Desired Protect state; 0 = off, PROTECT = on
; Destroy: A
setProtect:
        push bc
        and PROTECT         ; ensure only correct bit is accepted
        ld b,a              ; save A in B
        ld a,(SYS_MODE)     ; get current state
        and -PROTECT-1      ; clear bit
        jr updateMode       ; set mode and exit

; Set EXPAND state
; Input: A = Desired Expand state; 0 = off, EXPAND = on
; Destroy: A
setExpand:
        push bc
        and EXPAND          ; ensure only correct bit is accepted
        ld b,a              ; save A in B
        ld a,(SYS_MODE)     ; get current state
        and -EXPAND-1       ; clear bit
        jr updateMode       ; set mode and exit

; Toggle Caps Lock
; Input: none
; Destroy: A
toggleCaps:
        ld a,(SYS_MODE)     ; get current state
        xor CAPSLOCK        ; toggle bit
updateCTL:
        out (SYS_CTRL),a    ; update latch
        ld (SYS_MODE),a     ; save state
        ret

; Toggle SHADOW
; Input: none
; Destroy: A
toggleShadow:
        ld a,(SYS_MODE)     ; get current state
        xor SHADOW          ; toggle bit
        jr updateCTL        ; update control

; Toggle PROTECT
; Input: none
; Destroy: A
toggleProtect:
        ld a,(PROT_MODE)    ; get protect mode status
        xor PROTECT         ; toggle bit
        ld (PROT_MODE),a    ; return it back
        ld a,(SYS_MODE)     ; get current state
        xor PROTECT         ; toggle bit
        jr updateCTL        ; update control

; Toggle EXPAND
; Input: none
; Destroy: A
toggleExpand:
        ld a,(XPND_MODE)    ; get expand mode status
        xor EXPAND          ; toggle bit
        ld (XPND_MODE),a    ; return it back
        ld a,(SYS_MODE)     ; get current state
        xor EXPAND          ; toggle bit
        jr updateCTL        ; update control

; Toggle Key Press Beep
; Input: none
; Destroy: A
toggleBeep:
        ld a,(KEY_BEEP)     ; get current state
        cpl                 ; twos complement
        ld (KEY_BEEP),a     ; save it back
        ret

; Toggle Auto increment address after second nibble keyed
; Input: none
; Destroy: A
toggleAutoAddress:
        ld a,(KEY_AUTO)     ; get current state
        cpl                 ; twos complement
        ld (KEY_AUTO),a     ; save it back
        ret

; Display credits via menu
displayCredits:
        ld hl,creditsCFG
        call menuDriver

; Display setting menu
displaySettings:
        ld hl,settingsCFG
        call menuDriver

; ----------------------------------------------------------------------------------------------------------------
; Strings, Constants, JP tables etc.
; ----------------------------------------------------------------------------------------------------------------
        .org BASE_ADDR+1000H
;Initial defaults on Hard Boot (Copied to RAM)
;MCB = Bits 0,1 = Data Nibbles Entered
;      Bit 2 = Address=H/Data=L mode
;      Bit 3 = LCD=H/Segment=L mode
;      Bit 4 = Disassembler View=H/Data Entry View=L mode (for segment mode only)
;      Bit 5 = Menu=L/Parameter=H Format for Menu handler (for LCD mode only)
defaults:
        .dw USER_ADDR       ;Initial Editing Location
        .db 08H             ;Monitor Control Byte (Default LCD Menu Mode)
        .db 00H             ;Key Buffer
        .db 20H             ;Key Press Flag (non zero = no press)
        .db 00H             ;Auto Increment
        .db 00H             ;Key repeat timer
        .db 00H             ;Key Beep On/Off
        .db 00H             ;Matrix Second Key Buffer
        .db 00H             ;Byte Count
        .dw USER_ADDR       ;Disassembler/Editor Starting Location
        .dw INTHandler      ;INT User jump routine (default RET)
        .dw NMIHandler      ;NMI User jump routine (default RET)
        .db 00H             ;Menu postion
        .db 00H             ;Menu selection
        .db 00H             ;Menu count
        .dw mainMenuCFG     ;Menu configuration
        .dw TOP_RAM         ;Default High RAM
defaultsSize:    .equ $-defaults

;LCD Initiliastion codes
LCDInitTable:
        .db 38H             ;8-Bit, 2 Lines
        .db 01H             ;Clear Display
        .db 06H             ;No Shift, Cursor move right
        .db 0CH             ;Display On, Cursor Off

;LCD Row Column 1 Values
LCDBaseRows:
        .db LCD_ROW1,LCD_ROW2,LCD_ROW3,LCD_ROW4

;Hexidecimal to Seven Segment display
hexToSegmentTable:
        .db 0EBH,28H,0CDH,0ADH,2EH,0A7H,0E7H,29H ;0-7
        .db 0EFH,2FH,6FH,0E6H,0C3H,0ECH,0C7H,47H ;8-F

; Jump table to various routines and function when a Fn+key is pressed
functionJumpTable:
        .dw switchMode      ;0 = Change from LCD Menu to Data entry mode
        .dw intelHexLoad    ;1 = Intel Hex File Loader
        .dw 0000H           ;2
        .dw 0000H           ;3
        .dw 0000H           ;4
        .dw 0000H           ;5
        .dw 0000H           ;6
        .dw 0000H           ;7
        .dw 0000H           ;8
        .dw 0000H           ;9
        .dw 0000H           ;A
        .dw dumbCopy        ;B = Block Backup
        .dw smartCopy       ;C = Smart Copy
        .dw switchView      ;D = Switch between Hex and Disassembly view
        .dw toggleExpand    ;E = Toggle Expand
        .dw 0000H           ;F

ASCIISegTable:
        .db 00H,18H,0AH,0EEH,0A7H,5CH,2CH,02H       ;  ! " # $ % & '
        .db 83H,89H,0A3H,46H,40H,04H,10H,4CH        ;( ) * + , - . /
        .db 0EBH,28H,0CDH,0ADH,2EH,0A7H,0E7H,29H    ;0 1 2 3 4 5 6 7
        .db 0EFH,0AFH,81H,0A1H,07H,84H,0DH,5DH      ;8 9 : ; < = > ?
        .db 0EDH,6FH,0E6H,0C3H,0ECH,0C7H,47H,0E3H   ;@ A B C D E F G
        .db 6EH,42H,0E8H,67H,0C2H,61H,6BH,0EBH      ;H I J K L M N O
        .db 4FH,8FH,4BH,0A7H,0C6H,0EAH,0EAH,8AH     ;P Q R S T U V W
        .db 6EH,0AEH,0CDH,0C3H,26H,0A9H,0BH,80H     ;X Y Z [ \ ] ^ _
        .db 08H,0EDH,0E6H,0C4H,0ECH,0CFH,47H,0AFH   ;` a b c d e f g
        .db 66H,40H,0A0H,67H,42H,60H,64H,0E4H       ;h i j k l m n o
        .db 4FH,2FH,44H,0A7H,0C6H,0E0H,0E0H,60H     ;p q r s t u v w
        .db 6EH,0AEH,0CDH,2CH,42H,46H,01H           ;x y z { | } ~

passText:
        .db 4FH,6FH,0A7H,0A7H,00H,00H               ;PASS
errorText:
        .db 0C7H,4BH,4BH,0EBH,4BH,00H               ;ERROR
breakText:
        .db 0C3H,4FH,0EAH,00H,0E6H,4FH              ;CPU bP

breakPointRegs:
        .db "AF=",0,"HL=",0,"BC=",0,"DE=",0
        .db "IX=",0,"IY=",0,"PC=",0,"SP=",0
breakPointRows:
        .db 80H,88H,0C0H,0C8H,94H,9CH,0D4H,0DCH
breakPointFlags:
        .db "SZYHXPNC"
breakPointFlagRows:
        .db 91H,0D1H,0A5H,0E5H,00H

sysCtrlRows:
        .db 80H,8AH,0C0H,0CAH,94H,9EH,0D4H,0DEH
sysCtrlText:
        .db "Shadow ",0,"Protect ",0,"Expand ",0,"FF-D3   ",0
        .db "FF-D4  ",0,"FF-D5   ",0,"FF-D6  ",0,"Caps    ",0

;Hard Reset Tune
hardResetTune:
        .db 01H,01H,00H,00H,12H,12H,17H,17H
        .db 16H,16H,12H,12H,00H,00H,00H,1FH
;Hard Reset Message
hardResetMessage:
        .db 0A5H,"------==",0F4H,0F4H,"==------",0A5H
        .db "| TEC-1G Computer  |"
        .db "|   Open Source!   |"
        .db 0A5H,"------==",0F4H,0F4H,"==------",0A5H,0

;Main Menu Configuration
mainMenuCFG:
        .db 12   ;twelve entries
           ;"                   " <- Max LCD entry width
        .db "= TEC-1G Main Menu =",0
        .db "Intel HEX Load",0
        .dw intelHexLoad
        .db "Smart Block Copy",0
        .dw smartCopy
        .db "Block Backup",0
        .dw dumbCopy
        .db "Export Z80 Assembly",0
        .dw assemblyToSerial
        .db "Export Raw Data",0
        .dw dataToSerial
        .db "Export Hex Dump",0
        .dw hexDumpToSerial
        .db "Import Binary File",0
        .dw dataFromSerial
        .db "Tiny Basic",0
        .dw tinyBasic
        .db "Music Routine",0
        .dw playTuneMenu
        .db "Setting",0
        .dw displaySettings
        .db "Credits",0
        .dw displayCredits
        .db " Version: ",REL_TXT,0
        .dw 0000H

menuSegmentData:
        .db "TEC-1G"

;Settings Menu
settingsCFG:
        .db 3
           ;"                   " <- Max LCD entry width
        .db "=  TEC-1G Settings =",0
        .db "Toggle Key Beep",0
        .dw toggleBeep
        .db "Toggle Address Inc",0
        .dw toggleAutoAddress
        .db "Toggle EXPAND",0
        .dw toggleExpand

;Credits Menu
creditsCFG:
        .db 8   ;eight entries
           ;"                   " <- Max LCD entry width
        .db "=  TEC-1G Credits  =",0
        .db "Mark Jelic - Design",0
        .dw 0000H
        .db "Brian Chiha - Coder",0
        .dw 0000H
        .db "Craig Hart - TECGuy",0
        .dw 0000H
        .db "Ian McLean - Tester",0
        .dw 0000H
        .db "James Elphick - ^^^",0
        .dw 0000H
        .db "- Original Design -",0
        .dw 0000H
        .db "   by John Hardy   ",0
        .dw 0000H
        .db "   and Ken Stone   ",0
        .dw 0000H

        .org BASE_ADDR+1400H
APITable:
        .dw softwareID
        .dw versionID
        .dw preInit
        .dw beep
        .dw convAToSeg
        .dw regAToASCII
        .dw ASCIItoSegment
        .dw stringCompare
        .dw HLToString
        .dw AToString
        .dw scanSegments
        .dw displayError
        .dw LCDBusy
        .dw stringToLCD
        .dw charToLCD
        .dw commandToLCD
        .dw scanKeys
        .dw scanKeysWait
        .dw matrixScan
        .dw joystickScan
        .dw serialEnable
        .dw serialDisable
        .dw txByte
        .dw rxByte
        .dw intelHexLoad
        .dw sendToSerial
        .dw receiveFromSerial
        .dw sendAssembly
        .dw sendHex
        .dw genDataDump
        .dw checkStartEnd
        .dw menuDriver
        .dw paramDriver
        .dw timeDelay
        .dw playNote
        .dw playTune
        .dw playTuneMenu
        .dw getCaps
        .dw getShadow
        .dw getProtect
        .dw getExpand
        .dw setCaps
        .dw setShadow
        .dw setProtect
        .dw setExpand
        .dw toggleCaps
        .dw toggleShadow
        .dw toggleProtect
        .dw toggleExpand
API_COUNT:  .equ    $-APITable  ;Total number of API functions

        .org BASE_ADDR+1500H
APITable2:
        .dw initLCD            ;Initalise the LCD
        .dw clearGBUF          ;Clear the Graphics Buffer
        .dw clearGrLCD         ;Clear the Graphics LCD Screen
        .dw clearTxtLCD        ;Clear the Text LCD Screen
        .dw setGrMode          ;Set Graphics Mode
        .dw setTxtMode         ;Set Text Mode
        .dw drawBox            ;Draw a rectangle between two points
        .dw drawLine           ;Draw a line between two points
        .dw drawCircle         ;Draw a circle from Mid X,Y to Radius
        .dw drawPixel          ;Draw one pixel at X,Y
        .dw fillBox            ;Draw a filled rectangle between two points
        .dw fillCircle         ;Draw a filled circle from Mid X,Y to Radius
        .dw plotToLCD          ;Display the Graphics Buffer to the LCD Screen
        .dw printString        ;Print Text on the screen in a given row
        .dw printChars         ;Print Characters on the screen in a given row and column
        .dw delayUS            ;Microsecond delay for LCD updates
        .dw delayMS            ;Millisecond delay for LCD updates
        .dw setBufClear        ;Clear the Graphics buffer on after Plotting to the screen
        .dw setBufNoClear      ;Retain the Graphics buffer on after Plotting to the screen
        .dw clearPixel         ;Remove a Pixel at X,Y
        .dw flipPixel          ;Flip a Pixel On/Off at X,Y

API_COUNT2:  .equ    $-APITable2  ;Total number of GLCD API functions

; END OF CORE MONITOR

; Monitor Packages
        .org BASE_ADDR+1600H
        .include "packages.z80"

APINames:
_softwareID       .equ 0
_versionID        .equ 1
_preInit          .equ 2
_beep             .equ 3
_convAToSeg       .equ 4
_regAToASCII      .equ 5
_ASCIItoSegment   .equ 6
_stringCompare    .equ 7
_HLToString       .equ 8
_AToString        .equ 9
_scanSegments     .equ 10
_displayError     .equ 11
_LCDBusy          .equ 12
_stringToLCD      .equ 13
_charToLCD        .equ 14
_commandToLCD     .equ 15
_scanKeys         .equ 16
_scanKeysWait     .equ 17
_matrixScan       .equ 18
_joystickScan     .equ 19
_serialEnable     .equ 20
_serialDisable    .equ 21
_txByte           .equ 22
_rxByte           .equ 23
_intelHexLoad     .equ 24
_sendToSerial     .equ 25
_receiveFromSerial .equ 26
_sendAssembly     .equ 27
_sendHex          .equ 28
_genDataDump      .equ 29
_checkStartEnd    .equ 30
_menuDriver       .equ 31
_paramDriver      .equ 32
_timeDelay        .equ 33
_playNote         .equ 34
_playTune         .equ 35
_playTuneMenu     .equ 36
_getCaps          .equ 37
_getShadow        .equ 38
_getProtect       .equ 39
_getExpand        .equ 40
_setCaps          .equ 41
_setShadow        .equ 42
_setProtect       .equ 43
_setExpand        .equ 44
_toggleCaps       .equ 45
_toggleShadow     .equ 46
_toggleProtect    .equ 47
_toggleExpand     .equ 48

APINames2:
_initLCD          .equ 0  ;Initalise the LCD
_clearGBUF        .equ 1  ;Clear the Graphics Buffer
_clearGrLCD       .equ 2  ;Clear the Graphics LCD Screen
_clearTxtLCD      .equ 3  ;Clear the Text LCD Screen
_setGrMode        .equ 4  ;Set Graphics Mode
_setTxtMode       .equ 5  ;Set Text Mode
_drawBox          .equ 6  ;Draw a rectangle between two points
_drawLine         .equ 7  ;Draw a line between two points
_drawCircle       .equ 8  ;Draw a circle from Mid X,Y to Radius
_drawPixel        .equ 9  ;Draw one pixel at X,Y
_fillBox          .equ 10 ;Draw a filled rectangle between two points
_fillCircle       .equ 11 ;Draw a filled circle from Mid X,Y to Radius
_plotToLCD        .equ 12 ;Display the Graphics Buffer to the LCD Screen
_printString      .equ 13 ;Print Text on the screen in a given row
_printChars       .equ 14 ;Print Characters on the screen in a given row and column
_delayUS          .equ 15 ;Microsecond delay for LCD updates
_delayMS          .equ 16 ;Millisecond delay for LCD updates
_setBufClear      .equ 17 ;Clear the Graphics buffer on after Plotting to the screen
_setBufNoClear    .equ 18 ;Retain the Graphics buffer on after Plotting to the screen
_clearPixel       .equ 19 ;Remove a Pixel at X,Y
_flipPixel        .equ 20 ;Flip a Pixel On/Off at X,Y

        .org BASE_ADDR+3FECH    ; 16k

RELMAJOR:   .dw 07E7h	; 2023 - for the API
RELMINOR:   .dw 000Bh
SOFTWARE:   .db "MON3.1G",0
RELEASE:    .db REL_TXT,0
<<<<<<< HEAD:ROMs/MON3/src/mon3.z80
REL_TXT:    .equ "2023.0B"
=======
REL_TXT:    .equ "BC23.10"
>>>>>>> af03c933342f1e45ca96978d6fbb5cd4cf9046b7:ROMs/MON3/source/mon3.z80

        .end

        .binfrom 0C000H